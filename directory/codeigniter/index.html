<!DOCTYPE html>
<html>
<head>
    <!-- Meta tags -->
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="author" content="ვასილ ნადირაძე"/>
    <meta name="description" content="Codeigniter-ის ცნობარი, განმარტებები, მაგალითები">
    <meta name="keywords"  content="Codeigniter,ფრეიმვორკი,ცნობარი,ვებ-დეველოპმენტი,დეველოპმენტი,საიტი,საიტები" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- CSS -->
    <link rel="stylesheet" type="text/css" href="../../public/styles/style.css" >
    <style type="text/css">@font-face {font-family: "First Font"; src: url(../../public/fonts/first.ttf) format("truetype"); }</style>
    <!-- Title -->
    <title>Codeigniter ცნობარი</title>
    
    <style>
      img{
        display: block;
        max-width: 700px;
        height: auto;
        margin: 0px auto;
        border: 1px solid black;
      }
      h1,h2,h3,code{
        margin: 30px 0;
      }
    </style>
</head>
<body >

<BR><BR>

<div class="content">
    <h2 style="margin-left: 25px;">ძირითადი კონცეფციები</h2>
</div>

<BR><BR>

<div class="content">
    <dl class="faqs">


      <dt>1. რა არის CodeIgniter ?</dt>
      <dd class='answer'>

          CodeIgniter - ეს არის აპლიკაციების შესაქმნელი პლატფორმა, ფრეიმვორკი - ინსტრუმენტთა ნაკრები იმ პროგრამისტებისათვის, რომლებიც PHP-ის
          მეშვეობით ამზადებენ ვებ-გვერდებს. ფრეიმვორკის  დახმარებით გაცილებით სწრაფად და მარტივად ვქმნით აპლიკაციებს და აღარ გვიწევს კოდის წერის
          დაწყება ნოლიდან. CI მოიცავს ბიბლიოთეკების მრავალფეროვან ნაკრებს და მარტივ ინტერფეისს, აგრეთვე მარტივ ლოგიკურ სტრუქტურას ამ
          ბიბლიოთეკებთან  წვდომისათვის.  CI  არის MVC პრინციპზე დაფუძნებული ფრეიმვორკი.

          <h2>მახასიათებლები</h2>

          <ul>
            <li>
              CodeIgniter გამოირჩევა სიმარტივით, სიმარტივეს კი განაპირობებს შემდეგი ფაქტორები
              <ul>
                <li>ხელმისაწვდომია ხარისხიანი და სრული დოკუმენტაცია რომელშიც მოყვანილია მაგალითები.</li>
                <li>
                  არსებობს უამრავი ვიდეო-გაკვეთილი, როგორც <a href="https://codeigniter.com/" target="_blanck">ოფიციალურ საიტზე</a>,
                  ასევე ზოგადად ინტერნეტ-სივრცეში.
                </li>
                <li>
                  ფრეიმვორკი პროგრამისტს აძლევს მოქმედების თავისუფლებას, რაიმე სახის სტრუქტურული შეზღუდვებისა და კონვენციების
                  შექმნის გარეშე.
                </li>
              </ul>
            </li>
            <li>CodeIgniter მუშაობს თითქმის ყველა ჰოსტინგ-პროვაიდერთან, რომელსაც აქვს PHP 5.1 და უფრო ახალი ვერსიების მხარდაჭერა.</li>
            <li>CodeIgniter ითვლება ერთ-ერთ ყველაზე სწრაფ ფრეიმვორკად.</li>
          </ul>


          <h2>შესაძლებლობები</h2>

          <ul>
            <li>MySQL, PostgreSQL, MSSQL, SQLite, Oracle მონაცემთა ბაზების მხარდაჭერა. </li>
            <li>
              როგორც ჩვეულებრივი (მაგ: /index.php?cat=10&subcat=2&id=41 ) ასევე ადამიანისათვის გასაგები (რუს: ЧПУ - человекопонятный URL,
              ინგლ: friendly URL, მაგ: /product/phone/Samsung/) URL მისამართების მხარდაჭერა.
            </li>
            <li>
              ფრეიმვორკი შეიცავს ისეთ ბიბლიოთეკებს, რომლების გამოიყენება ფაილებთან სამუშაოდ, ელ_ფოსტის გასაგზავნად, ფორმების ვალიდაციისათვის,
              სესიების მხარდასაჭერად, გამოსახულებებთან სამუშაოდ და ა.შ
            </li>
          </ul>

          <h2>ინსტალაცია</h2>

          CI-ს ინსტალაცია საკმაოდ მარტივია
          <ul class="list">
              <li>
                გადმოვწეროთ  CI შემდეგი მისამართიდან : <a target="_blank" rel="nofollow" href="http://www.codeigniter.com/download">CodeIgniter</a>
              </li>
              <li>გავხსნათ დაარქივებული ფაილი.</li>
              <li>ავტვირთოთ არქივში არსებული ყველა ფაილი სერვერზე</li>
              <li>ატვირთვის შემდეგ გავხსნათ ჩვენი სერვერის URL მისამართი, მაგ: http://localhost/codeigniter</li>
          </ul>
          ამ მისამართზე შესვლის შემდეგ უნდა დავინახოთ შემდეგი სურათი
          <br /><br />
          <img src="images/codeigniter.jpg" alt="">
          <br /><br />

          <h2>CodeIgniter - აპლიკაციის არქიტექტურა</h2>

          <img src="images/architecture_codeigniter.jpg" alt="">
          <br /><br />

          <ul class="list">
            <li>როგორც ვხედავთ, როგორც კი CI მიიღებს რაიმე მოთხოვნას, მოთხოვნა მიემართება <b>index.php</b> გვერდისკენ.</li>
            <li>
              მეორე ბიჯზე <b>Routing ანუ მარშრუტიზატორი</b> წყვეტს საით გაგზავნოს მოთხოვნა ბიჯი-3-სკენ თუ ბიჯი-4-სკენ უსაფრთხოების
              გადასამოწმებლად.
            </li>
            <li>
              თუ მოთხოვნა უკვე მოხვედრილია <b>კეშირების</b> პროცესში, მაშინ <b>მარშრუტიზატორი</b> მოთხოვნას გაგზავნის ბიჯი-3-სკენ და პასუხი
              დაუბრუნდება  მომხმარებელს.
            </li>
            <li>
              თუ მოთხოვნა არ არის დამუშავებული, მაშინ  <b>მარშრუტიზატორი</b> მას გაგზავნის ბიჯი-4-სკენ <b>უსაფრთხოების</b> გადასამოწმებლად.
            </li>
            <li>
              მანამ მოთხოვნა გადაეცემა <b>ძირითად კონტროლერს ანუ Application Controller-ს</b>, გამოგზავნილ მოთხოვნაში შემავალი ინფორმაცია უკვე
              გადამოწმებულია <b>უსაფრთხოების</b>  თვალსაზრისით, <b>ძირითადი კონტროლერი ანუ Application Controller</b> მოითხოვს ყველა
              აუცილებელ <b>მოდელს, ბიბლიოთეკას, დამხმარეს, პლაგინს</b>  <b>სკრიპტს</b> და გადასცემს მათ <b>წარმოდგენას ანუ View-ს</b>.
            </li>
            <li>
              <b>წარმოდგენა ანუ View</b> შექმნის საჭირო ინფორმაციის შემცველ გვერდს და ჩართავს მას კეშირების პროცესში, შემდეგ დაბრუნდება
              საბოლოო შედეგი და გვერდი მზად იქნება ახალი მოთხოვნის მისაღებად
          </ul>


          <h2>CodeIgniter - დირექტორიების სტრუქტურა</h2>

          ქვემოთ მოყვანილ სურათზე ასახულია CI დირექტორიების სტრუქტურა
          <br /><br />
          <img src="images/directory_structure.jpg" alt="">
          <br /><br />

          CI დირექტორიების სტრუქტურა იყოფა სამ საქაღალდედ

          <ul class="list">
            <li>Application</li>
            <li>System</li>
            <li>User_guide</li>
          </ul>

          <h3>Application</h3>

          დასახელებიდანაც ჩანს, რომ ეს საქაღალდე შეიცავს ჩვენი აპლიკაციის მთლიან კოდს, ესაა საქაღალდე სადაც ვქმნით პროექტს, საქაღალდე შეიცავს
          შემდეგ ქვე-საქაღალდეებს

          <ul class="list">
            <li>
              <b>Cache</b> &minus; ეს საქაღალდე შეიცავს ჩვენი პროექტის ყველა კეშირებულ გვერდს, კეშირებული გვერდების მეშვეობით
              აპლიკაცია ხდება უფრო სწრაფი.
            </li>
            <li>
              <b>Config</b> &minus; ეს საქაღალდე შეიცავს კონფიგურაციულ ფაილებს,  <b>config.php</b> ფაილში პროგრამისტს შეიძლია განსაზღვროს
              სხვადასხვა კონფიგურაციული პარამეტრები. <b>database.php</b> ფაილში კი შესაძლებელია მონაცემთა ბაზის პარამეტრების მითიტება.
            </li>
            <li>
              <b>Controllers</b> &minus; ეს საქაღალდე შეიცავს აპლიკაციის კონტროლერებს, ეს არის აპლიკაციის ძირითადი ნაწილი.
            </li>
            <li>
              <b>Core</b> &minus; ეს საქაღალდე შეიცავს აპლიკაციის ძირითად კლასს.
            </li>
            <li>
              <b>Helpers</b> &minus; ამ საქაღალდეში შეიძლება მოთავსდეს აპლიკაციის დამხმარე კლასები.
            </li>
            <li>
              <b>Hooks</b> &minus; ამ საქაღალდეში განთავსებული ფაილები საშუალებას გვაძლევენ სხვაგვარად დავგეგმოთ ფრეიმვორკში მიმდინარე
              შიდა სამუშაოები ძირითადი ფაილების შეუცვლელად.
            </li>
            <li>
              <b>Language</b> &minus; ეს საქაღალდე შეიცავს ენასთან დაკავშირებულ ფაილებს.
            </li>
            <li>
              <b>Libraries</b> &minus; ეს საქაღალდე შეიცავს აპლიკაციისათვის შექმნილი ბიბლიოთეკების ფაილებს.
            </li>
            <li>
              <b>Logs</b> &minus; ეს საქაღალდე შეიცავს სისტემის მუშობის ამსახველ ფაილებს.
            </li>
            <li>
              <b>Models</b> &minus; აქ განთავსდება მონაცემთა ბაზასთან დაკავშირებული ფაილები.
            </li>
            <li>
              <b>Third_party</b> &minus; ამ საქაღალდეში შეიძლება მოვათავსოთ აპლიკაციისათვის საჭირო სხვადასხვა პლაგინები.
            </li>
            <li>
              <b>Views</b> &minus; აქ მოთავსდება აპლიკაციის HTML ფაილები.
            </li>
          </ul>


          <h3>System</h3>


          ეს საქაღალდე შეიცავს CI-ს ძირითად კოდებს, ბიბლიოთეკებს, დამხმარეებს და სხვა ფაილებს, რომლებიც გვეხმარებიან კოდის წერა გავხადოთ
          უფრო ადვილი.

          <ul class="list">
            <li>
              <b>Core</b> &minus; ეს საქაღალდე შეიცავს CI-ს ძირითად კლასს. <b>არავითარ შემთხვევაში არ შეიძლება ამ საქაღალდეში რაიმეს შეცვლა</b>
              ჩვენთვის საჭირო ფაილები მოთავსებულია application საქაღალდეში.
             </li>
            <li>
              <b>Database</b> &minus; საქაღალდე შეიცავს მონაცემთა ბაზის ძირითად დრაივერსა და მის სხვა ხელსაწყოებს.
            </li>
            <li>
              <b>Fonts</b> &minus; საქაღალდე შეიცავს ფონტებთან დაკავშირებულ ინფორმაციებს.
            </li>
            <li>
              <b>Helpers</b> &minus; საქაღალდე შეიჩავს სტანდარტულ CI დამხმარეებს (თარიღი, cookie და URL დამხმარეები).
            </li>
            <li>
              <b>Language</b> &minus; საქაღალდე შეიცავს ენასთან დაკავშირებულ ფაილებს.
            </li>
            <li>
              <b>Libraries</b> &minus; საქაღალდე შეიჩავს სტანდარტულ CI ბიბლიოთეკებს (ელ_ფოსტა, კალენდარი, ფაილების ატვირთვა
              და ა.შ ).  შეგვიძლია შევქმნათ საკუთარი ბიბლკიოთეკებიც, მაგრამ ისინი უნდა შევინახოთ <b>application/libraries</b> საქაღალდეში
              რათა განვაცალკევოთ CI სტანდარტული ბიბლიოთეკებისაგან.
             </li>
          </ul>

          <h3>User_guide</h3>

          ეს არის ჩვენი გიდი  CI-ში, მისი მეშვეობით შეგვიძლია შევისწავლოთ სხვბადასხვა ბიბლიოთეკების ფუნქციები, დამხმარეები და კლასები.
          ჩვენი პირველი CI აპლიკაციის შექმნამდე რეკომენდებულია გავეცნოთ CI გიდს. <br /><br />

          გარდა ზემოთ ჩამოთვლილი საქაღალდეებისა ძირ დირექტორიაში არის ერთი მნიშვნელოვანი ფაილი <b>index.php</b>, აქ შეგვიძლია
          განვსაზღროთ ან შევცვალოთ აპლიკაციის სამუშაო გარემო და შეცდომათა გამოტანის სისტემა, აგრეთვე სისტემისა და აპლიკაციის საქაღალდეთა
          სახელები. რეკომენდებულია არ შევცვალოთ ამ საქაღალდეში განსაზღვრული პარამეტრები თუ ზუსტად არ ვიცით რას ვაკეთებთ.


      </dd>

      <dt>2. რა არის MVC ?</dt>
      <dd class='answer'>


          MVC (Model–View–Controller ანუ მოდელი-წარმოდგენა-კონტროლერი) - არის კომპიუტერულ ინჟინერიაში გავრცელებული, კოდირების
          შაბლონი,  მეთოდი, იდეა, რომელიც საშუალებას  იძლევა  განცალკევდეს ვებ-აპლიკაციის ლოგიკა და მისი წარმოდგენა ანუ ის ნაწილი
          რომელსაც მომხმარებელი ხედავს ბრაუზერში.
          <br /><br />
          <img src="images/mvc.png" alt="">
          <br /><br />
          ეს განცალკევება აპლიკაციას ხდის უფრო მოქნილს და ადვილად კორექტირებადს რადგან თუ გვსურს ვიზუალური მხარის  ჩასწორება
          საქმე გვაქვს მხოლოდ მასთან და არა ლოგიკურ ფუნქციონალიტეტთან და პირიქით.

          <h2>წარმოდგენა</h2>

          MVC-ს ელემენტს - წარმოდგენა (view), ინფორმაცია გამოაქვს ეკრანზე. ეს არის აპლიკაციის დიზაინერული ნაწილი მინიმალური ლოგიკით.
          წარმოდგენა შეიძლება შედგებოდეს რამოდენიმე შაბლონისაგან.
          <br /><br />
          <img src="images/view.jpg" alt="">
          <br /><br />

          <h2>კონტროლერი</h2>

          MVC-ს ელემენტი - კონტროლერი არის მომხმარებლისა და აპლიკაციის წარმოდგენის დამაკავშირებელი ბლოკი. იგი იღებს ინფორმაციას
          მომხმარებლისაგან, ამუშავებს, ამოწმებს მას და ეს დამუშავებული ინფორმაცია ეგზავნება MVC-ს მესამე ელემენტს - მოდელს,  მისგან
          ღებულობს შესაბამის პასუხს და წყვეტს თუ წარმოდგენის რომელმა შაბლონმა უნდა დაუბრუნოს ეს პასუხი მომხმარებელს.
          <br /><br />
          <img src="images/controller.jpg" alt="">
          <br /><br />

          <h2>მოდელი</h2>

          MVC-ს მესამე ელემენტი - მოდელი, ეს არის ლოგიკის ძირითადი ნაწილი, რომელიც მუშაობს მონაცემებთან, ახდენს მონაცემებით მანიპულირებას.
          მოდელი იღებს კონტროლერისაგან რაიმე მოთხოვნას, შემდეგ მბ-დან მოაქვს შესაბამისი  ინფორმაცია და უბრუნებს კონტროლერს. სხვა სიტყვებით,
          რომ ვთქვათ მოდელის ფუნციაა მიიღოს მონაცემი, დაამუშავოს იგი და დააბრუნოს პასუხი.  პრაქტიკაში მოდელის რეალიზება ხშირად ხდება ხოლმე
          კლასის სახით, რომელსაც აქვს მონაცეთა დამუშავებისათვის განსაზღვრული მეთოდები.
          <br /><br />
          <img src="images/model.jpg" alt="">
          <br /><br />

          <h2>მუშაობის კლასიკური სქემა</h2>


          მომხმარებელმა გააკეთა მოთხოვნა საიტზე, მოთხოვნა გადაეცა საიტზე შესვლის ერთადერთ წერტილს (index.php, frontController), ამ წერტილში
          მოსულ მოთხოვნას ამუშავებს მარშრუტიზაციის კომპონენტი (Router), ერთგვარი გზამკვლევი მოთხოვნისათვის, როუტერმა უნდა განსაზღვროს
          თუ რომელმა კონტროლერმა უნდა დაამუშავოს მოთხოვნა
          <br /><br />
          <img src="images/scheme.jpg" alt="">
          <br /><br />
          ვთქვათ ეს კონტროლერია  NewsController, ეს კონტროლერი მოთხოვნიდან ღებულობს ინფორმაციას თუ რა სახის სიახლეების ნახვა უნდა მომხმარებელს,
          შემდეგ მიმართავს მოდელს საჭირო ინფორმაციის მისაღებად, პასუხის მიღების შემდეგ კონტროლერი იყენებს საჭირო წარმოდგენას პასუხის ბრაუზერში
          გამოსატანად, ასე იკვრება მთლიანი წრე.

      </dd>

      <dt>3. CI - URL მისამართები</dt>
      <dd class='answer'>

        ნაგულისხმეობის პრინციპით  CI-ში განსაზღვრულია საძიებო სისტემებისა და ადამიანის თვალისათვის ადვილად აღქმადი URL მისამართები. სტანდარტული
        URL მისამართების ჩაწერის სტანდარტული "მოთხოვნის ტექსტი" (მაგ: example.com?page=view&content=1...) ტიპის  ნაცვლად CI იყენებს სეგმენტურ მიდგომას
        <code>
          example.com/news/article/my_article
        </code>

        <h2>URL მისამართის სეგმენტები</h2>

        საბაზისო  URL მისამართს აქვს შემდეგი სახე
        <code>
          example.com/class/function/ID
        </code>

        URL მისამართის სეგმენტები, Model-View-Controller პრინციპის მიხედვით განსაზღვრავენ:

        <ol>
          <li>პირველი სეგმენტი განსაზღვრავს კონტროლერის <b>კლასს</b> რომლის გამოძახებაც უნდა მოხდეს.</li>
          <li>მეორე სეგმენტი განსაზღვრავს კლასის <b>მეთოდს</b> რომელიც უნდა შესრულდეს</li>
          <li>მესამე და შემდეგი სეგმენტები განსაზღვრავენ ID-ს და სხვა ცვლადებს, რომლებიც უნდა გადაეცეს კონტროლერს.</li>
        </ol>

        <h2>URL მისამართიდან index.php ტექსტის წაშლა</h2>

        ნაგულისმეობის პრინციპით URL მისამართებში შეტანილია index.php დასახელება
        <code>
          example.com/index.php/news/article/my_article
        </code>
        URL-დან მისი წაშლა შესაძლებელია <b>.htaccess</b> ფაილის მეშვეობით
        <code>
          RewriteEngine On<br />
          RewriteCond %{REQUEST_FILENAME} !-f<br />
          RewriteCond %{REQUEST_FILENAME} !-d<br />
          RewriteRule ^(.*)$ index.php/$1 [L]
        </code>
        მოყვანილ მაგალითში ნებისმიერი HTTP მოთხოვნა, რომელიც განსხვავდება არსებული დირექტორიების ან ფაილების მოთხოვნისაგან, აღიქმნება index.php
        ფაილის მოთხოვნად.
        <p>
          <b>.htaccess</b> ფაილში განსაზღვრულმა წესებმა შეიძლება არ იმუშავოს ყველანაირი სერვერული კონფიგურაციისათვის.
        </p>

        <h2>"მოთხოვნის სტრიქონი" ტიპის URL მისამართები</h2>

        შეიძლება მოხდეს რომ დაგვჭირდეს არა სეგმენტური URL მისამართები, არამედ შემდეგი სახის
        <code>
          index.php?c=products&m=view&id=345
        </code>
        თუ გავხსნით <b>application/config.php</b> ფაილს დავინახავთ შემდეგ ჩანაწერებს
        <code>
          $config['enable_query_strings'] = FALSE;<br />
          $config['controller_trigger'] = 'c';<br />
          $config['function_trigger'] = 'm';
        </code>
        თუ $config მასივის 'enable_query_strings' გასაღების მნიშვნელობად მივუთითებთ TRUE-ს, მაშინ შესძლებელი იქნება გავხსნათ შემდეგი ტიპის URL
        მისამართები
        <code>
          index.php?c=controller&m=method
        </code>


      </dd>

      <dt>4. CI - კონტროლერები</dt>
      <dd class='answer'>


        კონტროლერი - ეს არის უბრალო ფაილი სადაც აღწერილია კლასი. როგორც მისი დასახელებიდან ჩანს, იგი მართავს მთლიან აპლიკაციას  URI
        მისამართების დახმარებით. განვიხილოთ URL მისამართი
        <code>
          example.com/index.php/blog/
        </code>
        ამ მისამართზე შესვლისას CI შეეცდება მოძებნოს კონტროლერი <b>Blog.php</b> და ჩატვირთოს იგი. როდესაც კონტროლერის დასახელება დაემთხვევა URI-ის
        პირველ სეგმენტს, მოხდება ამ კონტროლერის ჩატვირთვა.

        <h3>კონტროლერის შექმნა</h3>

        შევიდეთ  <b>application/controllers</b> საქაღალდეში. აქ დაგვხვდება ორი ფაილი <b>index.html და Welcome.php</b>, ეს ფაილები მოყვება
        CI-ს.  გავაკეთოთ ახალი ფაილი "Blog.php” და ჩავწეროთ შემდეგი კოდი
        <code>
          <pre>
&lt;?php
class Blog extends CI_Controller{
  public function index(){
    echo "Hello Georgia";
  }
}
?>
          </pre>
        </code>
        <b>Blog</b> კლასი არის CI-ში ჩაშენებული კლასის <b>CI_Controller</b>-ის მემკვიდრე კლასი. <b>ფაილს უნდა დავარქვათ აუცილებლად Blog.php
        "B" დიდი ასოთი, აგრეთვე დიდი ასოთი უნდა დაიწყოს კონტროლერის კლასის დასახელებაც.</b>

        <h3>კონტროლერის გამოძახება</h3>

        ამ კონტროლერის გამოძახება შესაძლებელია თუ შევალთ შემდეგ მისამართზე
        <code>
          http://www.your-domain.com/index.php/blog
        </code>
        ბრაუზერში უნდა გამოჩნდეს ტექსტი "Hello Georgia" ; )


        <h3>კონტროლერის მეთოდები</h3>


        განვაახლოთ ზემოთ აღწერილი კლასი და დავამატოთ მას მეთოდი “framework”
        <code>
          <pre>
&lt;?php
class Blog extends CI_Controller {

  public function index(){
    echo "Hello Georgia";
  }

  public function framework() {
     echo "This is CodeIgniter !";
  }

}
?>
          </pre>
        </code>
        ამ კონტროლერის გაშვება შეიძლება სამნაირად
        <ul class="list">
          <li>http://www.your-domain.com/index.php/blog</li>
          <li>http://www.your-domain.com/index.php/blog/index</li>
          <li>http://www.your-domain.com/index.php/blog/framework</li>
        </ul>
        პირველ მისამართზე შესვლის შემდეგ ბრაუზერში გამოჩნდება ტექსტი "Hello Georgia" , როგორც ვხედავთ ვიხილეთ <b>index</b>
        მეთოდის მიერ გამოტანილი შედეგი, თუმცაღა URL-ში არ მიგვითითებია მეთოდის დასახელება, ჩვენ გამოვიყენეთ მხოლოდ კონტროლერის
        სახელი, <b>ამგვარ სიტუაციებში CI ნაგულისმეობის პრინციპით იძახებს კონტროლერის <b>index</b>  მეთოდს.</b>
        <p>
          მარტივი ასახსნელია რომ მეორე შემთხვევაშიც იგივე შედეგს ვიხილავთ ბრაუზერში. რაც შეეხება მესამე URL-ს, მასზე შესვლის შემდეგ ბრაუზერში
          გამოვა ტექსტი "This is CodeIgniter !" , ეს კი არის <b>framework</b> მეთოდის შედეგი, რადგან კონტროლერის დასახელების შემდეგ სწორედ
          ამ მეთოდის სახელია მითითებული URL-ში.
       </p>
       <b>URL მისამართის მეორე სეგმენტი განსაზღვრავს თუ კონტროლერის რომელი მეთოდის  გამოძახება უნდა მოხდეს.</b>

        <h3>უნდა გვახსოვდეს</h3>

        <ul>
          <li>კონტროლერის კლასის დასახელება უნდა დაიწყოს დიდი ასოთი.</li>
          <li>URL-ში კონტროლერი უნდა გამოვიძახოთ პატარა ასოთი.</li>
          <li>არ უნდა დავარქვათ მეთოდს იგივე სახელი რაც აქვს მის მშობელ კლასს.</li>
        </ul>

        <h2>URL სეგმენტების მეთოდებში გამოყენება</h2>

        თუ URL მისამართი შეიცავს ორ სეგმენტზე მეტს მაშინ საჭიროა ამ სეგმენტთა დასახელებების გამოყენება მეთოდების პარამეტრებად.
        <code>
          example.com/index.php/products/shoes/sandals/123
        </code>
        მეთოდს უნდა გადაეცეს URI-ის  3 და 4  სეგმენტები (“sandals” და “123”):
        <code>
          <pre>
&lt;?php
  class Products extends CI_Controller {

          public function shoes($sandals, $id){
                  echo $sandals;
                  echo $id;
          }
  }
          </pre>
        </code>

        <h2>ნაგულისმევი კონტროლერის განსაზღვრა</h2>

        შეიძლება მოხდეს ისე, რომ URL მისამართი არ შეიცავდეს კონტროლერის დასახელებას, მაგალითად იმ შემთხვბევაში თუ ჩვენი საიტის URL-ის მხოლოდ
        ფუძეს ავკრებთ
        <code>
          http://www.your-domain.com
        </code>
        ამ შემთხვევისათვის CI-მ წინასწარ უნდა იცოდეს თუ რომელი კონტროლერი ჩატვირთოს ნაგულისმევობის პრინციპით. ამისათვის უნდა გავხსნათ ფაილი
        <b>application/config/routes.php</b> და მივუთითოთ
        <code>
          $route['default_controller'] = 'blog';
        </code>
        სადაც 'blog' არის იმ კონტროლერის სახელი, რომელიც გვსურს, რომ ჩაიტვირთოს გვერდზე შესვლისას.

        <h2>Private მეთოდები</h2>

        შესაძლებელია დაგვჭირდეს საჯარო ხელმისაწვდომობისაგან დაცული მეთოდების შექმნა.  ამისათვის მეთოდი უნდა აღვწეროთ როგორც <b>private</b> ან
        <b>protected</b> და ის არ მოხდება URL მოთხოვნაში.
        <code>
          <pre>
private function _utility(){
        // some code
}
          </pre>
        </code>
        ამ მეთოდს ვერ დავუკავშირდებით URL მისამართით
        <code>
          example.com/index.php/blog/_utility/
        </code>

        <h2>კლასების კონსტრუქტორები</h2>

        თუ კონტროლერში ვაპირებთ კონსტრუქტორის გამოყენებას, მასში <b>აუცილებლად უნდა</b> მოვათავსოთ შემდეგი კოდი
        <code>
          parent::__construct();
        </code>
        ამ ჩანაწერის გამოყენების მიზეზი არის ის, რომ ჩვენს ლოკალურ კონსტრუქტორში მოხდეს მშობელი კლასის კონსტრუქტორის თავიდან განსაზღვრა
        <code>
          <pre>
&lt;?php
  class Blog extends CI_Controller {

          public function __construct(){
                  parent::__construct();
                  // Your own constructor code
          }
  }
          </pre>
        </code>
        კონსტრუქტორების გამოყენება ეფექტურია მაშინ, როდესაც გვინდა რომ ნაგულისმეობის პრინციპით განვსაზღროთ რაიმე მნიშვნელობები ან შევასრულოთ
        კონკრეტული ოპერაცია კლასის ეგზემპლიარის შექმნისას. კონსტრუქტორები არ აბრუნებენ შედეგს, მაგრამ შეუძლიათ ქმედების შესრულება ნაგულისმეობის
        პრინციპით.

      </dd>

      <dt>5. CI - წარმოდგენები</dt>
      <dd class='answer'>

        წარმოდგენა არის ვებ-გვერდი ან ვებ-გვერდის ფრაგმენტი (ქუდი, გვერდითი განყოფილება, ძირი და ა.შ). წარმოდგენა შეიძლება ჩადგმული იყოს სხვა
        წარმოდგენაში (მაგ: საიტის ქუდი და ძირი ძირითადი გვერდის წარმოდგენაში). წარმოდგენის  გამოძახება დაუყოვნებლივ არ ხდება, მას იძახებს კონტროლერი,
        გავიხსენოთ  რომ MVC მიდგომაში კონტროლერი მუშაობს როგორც პროექტ-მენეჯერი :)) და ის წყვეტს თუ რომელი წარმოდგენა უნდა ჩაიტვირთოს.

        <h2>წარმოდგენის შექმნა</h2>

        წარმოდგენები მოთავსებულია <b>application/views</b> საქაღალდეში, მასში შევქმნათ ფაილი  <b>blogview.php</b> შემდეგი კოდით
        <code>
          <pre>
&lt;html>
&lt;head>
        &lt;title>My Blog&lt;/title>
&lt;/head>
&lt;body>
        &lt;h1>Welcome to my Blog!&lt;/h1>
&lt;/body>
&lt;/html>
          </pre>
        </code>


        <h2>წარმოდგენის გამოძახება</h2>

        წარმოდგენის გამოძახების სინტაქსი შემდეგია
        <code>
          $this->load->view('დასახელება');
        </code>
        სადაც "დასახელება" არის საჭირო წარმოდგენის შესაბამისი ფაილის დასახელება რომელიც მოთავსებულია <b>application/views</b> დირექტორიაში,
        თუ სხვა დირექტორიაში მოთავსებული ფაილის გამოძახება გვსურს სინტაქსი ასეთია
        <code>
          $this->load->view('დირექტორია/დასახელება');
        </code>

        <b>.php გაფართოების მითითება აუცილებელი არ არის თუ არ ვიყენებთ სხვა რაიმეს გარდა .php-ისა.</b>

        <p>
          ახლა გავხსნათ ჩვენს მიერ შექმნილი Blog.php კონტროლერი და ჩავწეროთ შემდეგი კოდი
        </p>

        <code>
          <pre>
&lt;?php
  class Blog extends CI_Controller {

          public function index(){
                  $this->load->view('blogview');
          }
  }
          </pre>
        </code>
        index() მეთოდი იძახებს view() მეთოდს და აწვდის მას არგუმენტად “blogview”-ს რადგან ჩვენ გვჭირდება  <b>application/views/blogview.php</b>
        წარმოდგენის გამოძახება.  თუ ახლა შევალთ შემდეგ მისამართზე
        <code>
          example.com/index.php/blog/
        </code>
        ბრაუზერში ვიხილავთ blogview.php ფაილში აღწერილი კოდის შესაბამის შიგთავსს.


        <h2>რამოდენიმე წარმოდგენის ჩატვირთვა ერთდროულად</h2>

        თუ ერთ კონტროლერში რამოდენიმე წარმოდგენას ჩავტვირთავთ ბრაუზერში გამოვა ერთიანი შედეგი ამ გაერთიანებისა.

        <code>
          <pre>
&lt;?php

  class Page extends CI_Controller {

          public function index()
          {
                  $data['page_title'] = 'Your title';
                  $this->load->view('header');
                  $this->load->view('menu');
                  $this->load->view('content', $data);
                  $this->load->view('footer');
          }

  }
          </pre>
        </code>

        <h2>დინამიური ინფორმაციის შეტანა წარმოდგენაში</h2>

        კონტროლერიდან წარმოდგენაში დინამიური ინფორმაციის გაგზავნა შესაძლებელია <b>მასივის</b> ან <b>ობიექტის</b> მეშვეობით. ამ მასივის ან ობიექტის
        დასახელება მეორე პარამეტრად უნდა მიეთითოს <b>$this->load->view();</b> მეთოდს. მასივის შემთხვევაში
        <code>
          <pre>
$data = array(
        'title' => 'My Title',
        'heading' => 'My Heading',
        'message' => 'My Message'
);

$this->load->view('blogview', $data);
          </pre>
        </code>
        ობიექტის შემთხვევაში
        <code>
          <pre>
$data = new Someclass(); <br />
$this->load->view('blogview', $data);
          </pre>
        </code>
        გავაკეთოთ ეს ჩვენს Blog.php კონტროლერში
        <code>
          <pre>
&lt;?php
  class Blog extends CI_Controller {

          public function index()
          {
                  $data['title'] = "My Real Title";
                  $data['heading'] = "My Real Heading";

                  $this->load->view('blogview', $data);
          }
  }
          </pre>
        </code>
        წარმოდგენაში ანუ blogview.php ფაილში კი ამ ინფორმაციის გამოტანა მოხდება ასე
        <code>
          <pre>
&lt;html>
&lt;head>
        &lt;title>&lt;?php echo $title;?>&lt;/title>
&lt;/head>
&lt;body>
        &lt;h1>&lt;?php echo $heading;?>&lt;/h1>
&lt;/body>
&lt;/html>
          </pre>
        </code>

        <h2>ციკლის გამოყენება წარმოდგენაში</h2>

        მასივი,  რომლის მეშვეობითაც წარმოდგენაში ინფორმაციას ვაგზავნით, შეიძლება შეიცავდეს არა მარტო მარტივ ცვლადებს, ის შეიძლება შეიცავდეს
        სხვა მასივსაც
        <code>
          <pre>
&lt;?php
  class Blog extends CI_Controller {

          public function index()
          {
                  $data['todo_list'] = array('Clean House', 'Call Mom', 'Run Errands');

                  $data['title'] = "My Real Title";
                  $data['heading'] = "My Real Heading";

                  $this->load->view('blogview', $data);
          }
  }
          </pre>
        </code>
        წარმოდგენაში ამ ინფორმაციის გამოყენება მოხდება შემდეგნაირად
        <code>
          <pre>
&lt;html>
&lt;head>
        &lt;title>&lt;?php echo $title;?>&lt;/title>
&lt;/head>
&lt;body>
        &lt;h1>&lt;?php echo $heading;?>&lt;/h1>

        &lt;h3>My Todo List&lt;/h3>

        &lt;ul>
        &lt;?php foreach ($todo_list as $item):?>

                &lt;li>&lt;?php echo $item;?>&lt;/li>

        &lt;?php endforeach;?>
        &lt;/ul>

&lt;/body>
&lt;/html>
          </pre>
        </code>


      </dd>

      <dt>6. CI - მოდელები</dt>
      <dd class='answer'>

        მოდელი არის PHP  კლასი რომელიც შექმნილია  მონაცემთა ბაზასთან სამუშაოდ.  კლასი შეიძლება შეიცავდეს მეთოდებს, რომლებიც მბ-ში წაშლიან, ჩაამატებენ,
        დაარედაქტირებენ ჩანაწერებს.
        <code>
          <pre>
class Blog_model extends CI_Model {

        public $title;
        public $content;
        public $date;

        public function get_last_ten_entries() {
                $query = $this->db->get('entries', 10);
                return $query->result();
        }

        public function insert_entry() {
                $this->title    = $_POST['title']; // please read the below note
                $this->content  = $_POST['content'];
                $this->date     = time();

                $this->db->insert('entries', $this);
        }

        public function update_entry() {
                $this->title    = $_POST['title'];
                $this->content  = $_POST['content'];
                $this->date     = time();

                $this->db->update('entries', $this, array('id' => $_POST['id']));
        }

}
          </pre>
        </code>

        <h2>მოდელის ანატომია</h2>

        მოდელები განთავსებილია <b>application/models</b> საქაღალდეში. მოდელის საბაზისო პროტოტიპი არის შემდეგი
        <code>
          <pre>
class Model_name extends CI_Model {

        public function __construct() {
                parent::__construct();
                // Your own constructor code
        }

}
          </pre>
        </code>
        <b>Model_name</b> არის  კლასის დასახელება, რომელიც <b>უნდა იწყებოდეს</b> დიდი ასოთი, კლასი <b>უნდა იყოს CI-ს კლასის CI_Model-ის
        მემკვიდრე</b>.


        <h3>მოდელის ჩატვირთვა</h3>

        მოდელის გამოძახება შესაძლებელია კონტროლერის მეთოდებში შემდეგი სინტაქსის მიხედვით
        <code>
          $this->load->model('model_name');
        </code>
        მოდელის ჩატვირთვის შემდეგ შესაძლებელია მისი თვისებების გამოძახება
        <code>
          $this->model_name->method();
        </code>

        კონკრეტული მაგალითი
        <code>
          <pre>
class Blog_controller extends CI_Controller {

        public function blog(){

          // ჩავტვირთეთ მოდელი
          $this->load->model('blog');

          /*
           წარმოდგენისათვის გადასაცემ მასივს მივაბით მოდელის ფუნქცია,
           მაგალითად ბოლო 10 ჩანაწერის ამოღების ფუნქცია
          */
          $data['query'] = $this->blog->get_last_ten_entries();

          // ჩავტვირთეთ წარმოდგენა და მივამაგრეთ ინფორმაცია
          $this->load->view('blog', $data);
        }
}
          </pre>
        </code>



        <h3>ავტომატურად ჩამტვირთავი მოდელები</h3>

        ხშირია შემთხვევები, როდესაც საჭირო ხდება რომ რომელიმე მოდელის კლასი ავტომატურტად გაეშვეს, ჩაიტვირთოს. ამისათვის უნდა გავხსნათ
        <b>application/config/autoload.php</b>   ფაილი და შესაბამისი მოდელები შევიტანოთ <b>$autoload['model']</b> მასივში
        <code>
          $autoload['model'] = array();
        </code>
        ამ მასივში მითითებული  მოდელები ჩატვირთული იქნება აპლიკაციის ინიციალიზაციიდან მის გამორთვამდე.

      </dd>



      <dt>7. CI - დამხმარე ფუნქციები</dt>
      <dd class='answer'>

        დამხმარე ფუნქციები, როგორც მათი დასახელებიდან ჩანს, გვეხმარებიან ამოცანათა გადაჭრაში. დამხმარე ფაილის უკან მოიაზრება დამხმარე ფუნქციების
        ნაკრები.  არსებობს <b>URL დამხმარეები</b>, რომლებიც გვეხმარებიან ბმულების შექმნაში,  არსებობს <b>ფორმის დამხმარეები</b>, რომლებიც გვეხმარებიან
        ფორმის ელემენტების შექმნაში და ა.შ. CI-ს დამხმარე ფუნქციები არ არის ჩაწერილი ოოპ სტილში, ეს ფუნქციები ჩაწერილია მარტივი პროცედურული სტილის
        კოდებით. ყოველი დამხმარე ფუნქცია ასრულებს, სხვა ფუნქციებისაგან დამოუკიდებელ, კონკრეტულ დავალებას.
        <p>
          CI არ ტვირთავს ავტომატურად დამხმარე ფაილებს, ასე რომ თუ მათი გამოყენება გვინდა პირველ რიგში უნდა ჩავტვირთოთ ისინი. ჩატვირთვის შემდეგ
          მათზე გვაქვს გლობალური წვდომა კონტროლერებიდან და წარმოდგენებიდან.
        </p>
        <p>
          დამხმარეები მოთავსებულია <b>system/helpers</b> ან <b>application/helpers</b> საქაღალდეში, CI ჯერ ამოწმებს application/helpers საქაღალდეს.
          თუ ეს საქაღალდე არ შეიცავს საჭირო დამხმარეს მაშინ მოწმდება system/helpers დირექტორია.
        </p>

        <h2>დამხმარე ფუნქციის ჩატვირთვა</h2>

        ფუნქციის ჩატვირთვის სინტაქსი ასეთია
        <code>
          $this->load->helper('name');
        </code>
        სადაც <b>name</b> არის დამხმარე ფუნქციის შესაბამისი ფაილის დასახელება <b>.php</b>  გაფართოებისა და  <b>"helper"</b> ნაწილის გარეშე. მაგალითად
        თუ გვინდა ჩავტვირთოთ URL მისამართების შექმნის დამხმარე ფაილი, რომლის დასახელებაცაა <b>url_helper.php</b>, ვიქცევით ასე
        <code>
          $this->load->helper('url');
        </code>
        დამხმარეს ჩატვირთვა შესაძლებელია ნებისმიერ ადგილას კონტროლერში (ან წარმოდგენაში, თუმცა ეს კარგი პრაქტიკა არ არის), ბუნებრივია ჩატვირთვა უნდა
        მოხდეს დამხმარეს გამოყენებამდე. დამხმარე შეიძლება ჩაიტვირთოს კონტროლერის კონსტრუქტორი მეთოდის დახმარებით და ამის შემდეგ მასთან წვდომა
        შეგვეძლება კონტროლერის ყველა მეთოდიდან. შესაძლებელია რამოდენიმე დამხმარეს ერთდროულად ჩატვირთვაც
        <code>
          $this->load->helper(array('helper1', 'helper2', 'helper3'));
        </code>
        თუ გვსურს, რომ რომელიმე დამხმარე ავტომატურად ჩაიტვირთოს ამისათვის <b>application/config/autoload.php </b> ფაილში არსებულ შესაბამის მასივში
        უნდა შევიტანოთ ამ დამხმარეს დასახელება.

        <h2>დამხმარეს გამოყენება</h2>

        მას შემდეგ რაც ჩაიტვირთება დამხმარე, რომელიც შეიცავს საჭირო ფუნქციას, მისი გამოძახება შეგვიძლია ისევე როგორც გამოვიძახებდით სტანდარტულ PHP
        ფუნქციას.  მაგალითად ჩვენს რომელიმე წარმოდგენაში, <b>anchor()</b> ფუნქციის მეშვეობით ბმულის გასაკეთებლად, ვიქცევით ასე
        <code>
          &lt;?php echo anchor('blog/comments', 'Click Here');?>
        </code>
        სადაც “Click Here” არის ბმულის დასახელება, “blog/comments” კი არის კონტროლერის/მეთოდის URL რომელთან დაკავშირებაც გვინდა.


        <h2>არსებული დამხმარეების განვრცობა</h2>

        ჩვენი საკუთარი დამხმარეების შექმნა შესაძლებელია <b>application/helpers/</b> საქაღალდეში. სახელად კი უნდა დავარქვათ უკვევ არსებული ანუ CI-ში
        ჩაშენებული დამხმარეს სახელი წინსართ <b>MY_</b>-სთან ერთად. ამ წინსართის შეცვლა შესაძლებელია <b>application/config/config.php</b> ფაილში
        თუ არსებული დამხმარეს მხოლოდ განვრობა გვსურს ამისათვის შექმნილ ფაილში უნდა  დავამატოთ შესაბამისი ფუნქციები, ხოლო თუ უკვე მითითებული
        ფუნქციის გადაკეთება გვსურს მაშინ ახალ დამხმარეში უნდა შევქმნათ იგივე სახელის მქონე  საკუთარი ფუნქცია და ის გადაფარავს ძველს.

        <h2>დამხმარეების უპირატესობა</h2>

        იმისათვის რათა კარგად გავიგოთ თუ რა უპირატესობა აქვს დამხმარე ფუნქციებს და თუ რატომაა მათი გამოყენება კომფორტული, მოვიყვანოთ
        კონკრეტული მაგალითი. დავუშვათ გვაქვს ასეთი ამოცანა: მოცემულია ტექსი და გვსურს დავაბრუნოთ ამ ტექსტის პირველი ოთხი სიტყვისაგან
        შემდგარი სტრიქონი. ჩვეულებრივი PHP კოდით ამ ამოცანის გადაჭრის ერთ-ერთი ვარიანტია შემდეგი:
        <code>
          $str = "This is a Codeigniter tutorial"; <br />
          $array = array_slice(explode(" ",$str),0,4); <br />
          echo $new = implode(" ",$array);  //  This is a Codeigniter
        </code>
        ახლა ვნახოთ თუ როგორ შეიძლება იგივე ამოცანის გადაჭრა ტექსტური დამხმარეს შესაბამისი  ფუნქციის მეშვეობით 
        <code>
          $str = "This is a Codeigniter tutorial"; <br />
          echo $new =  word_limiter($str, 4);  // This is a Codeigniter
        </code>



      </dd>

      <dt>8. CI - ბიბლიოთეკები</dt>
      <dd class='answer'>

        ყველა ხელმისაწვდომი ბიბლიოთეკა მოთავსებულია <b>system/libraries</b> საქაღალდეში, ბიბლიოთეკის კლასის გამოსაყენებლად კონტროლერში უნდა
        მოვახდინოთ ამ კლასის ინიციალიზაცია შემდეგი სინტაქსის მიხედვით
        <code>
          $this->load->library('class_name');
        </code>
        სადაც ‘class_name’ არის საჭირო კასის დასახელება, მაგალითად ჩავტვირთოს ფორმის ვალიდაციის კლასი
        <code>
          $this->load->library('form_validation');
        </code>
        შესაძლებელია რამოდენიმე ბიბლიოთეკის ერთდროულად ჩატვირთვაც
        <code>
          $this->load->library(array('email', 'table'));
        </code>

        <h2>ბიბლიოთეკების შექმნა</h2>

        ბიბლიოთეკის შექმნისას შესაძლებელია მოვიქცეთ შემდეგნაირად
        <ul>
          <li>შესაძლებელია შექვქმნათ ახალი ბიბლიოთეკა.</li>
          <li>შესაძლებელია განვავრცოთ უკვე არსებული ბიბლიოთეკა</li>
          <li>შესძლებელია ჩავანაცვლოთ არსებული ბიბლიოთეკა ახლით.</li>
        </ul>
        ბიბლიოთეკები უნდა მოვათავსოთ b>system/libraries</b> საქაღალდეში. CI სწორედ აქ მოძებნის მათ, მას შემდეგ რაც ბიბლიოთეკების ინიციალიზაციას
        მოვახდენთ.

        <h2>სახელის დარქმევის წესები</h2>

        <ul>
          <li>ბიბლიოთეკის ფაილის დასახელება უნდა დაიწყოს დიდი ასოთი, მაგ: Myclass.php</li>
          <li>კლასის სახელი უნდა დაიწყოს დიდი ასოთი, მაგ: Myclass.</li>
          <li>ფაილისა და კლასის დასახელებები უნდა ემთხვბეოდეს ერთმანეთს.</li>
        </ul>

        <h2>კლასის ფაილი</h2>

        კლასის ძირითადი სტრუქტურა შემდეგნაირია
        <code>
          <pre>
&lt;?php
  defined('BASEPATH') OR exit('No direct script access allowed');

  class Someclass {

          public function some_method()
          {
          }
  }
          </pre>
        </code>

        <h2>კლასის გამოყენება</h2>

        კონტროლერში კლასის ინიციალიზაცია ხდება შემდგენაირად
        <code>
          $this->load->library('someclass');
        </code>
        ამის შემდეგ უკვე შესაძლებელია კლასის რომელიმე მეთოდის გამოძახება
        <code>
          $this->someclass->some_method();
        </code>

        <h2>პარამეტრების გადაცემა კლასის ინიციალიზაციისას</h2>

        ბიბლიოთეკის ჩატვირთვისას შესაძლებელია მეორე პარამეტრის მეშვეობით მივუთითოთ დამატებითი ინფორმაცია, რომელიც გამოყენებულ იქნება კლასში
        <code>
          <pre>
            $params = array('type' => 'large', 'color' => 'red'); <br />
            $this->load->library('someclass', $params);
          </pre>
        </code>
        ამის შემდეგ უნდა შევქმნათ კლასის კონსტრუქტორი
        <code>
          <pre>
&lt;?php defined('BASEPATH') OR exit('No direct script access allowed');

  class Someclass {

          public function __construct($params)
          {
                  // Do something with $params
          }
  }
          </pre>
        </code>

        <h2>ბიბლიოთეკების კლასები</h2>

        როგორც ვთქვით, ბიბლიოთეკების კლასები მოთავსებულია <b>system/libraries</b> საქაღალდეში, ყველა კლასს აქვს კონკრეტული ფუნქციონალიტეტი
        რომელიც ამარტივებს პროექტის წარმოების პროცესს

        <table>
            <tr>
                <th>N</th>
                <th style="text-align:center;">ბიბლიოთეკის კლასი &amp; აღწერა</th>
            </tr>
            <tr>
                <td>2</td>
                <td>
                  <p><b>Caching Class</b></p>
                  <p>This class will cache the pages, to quickly access the page speed.</p>
                </td>
            </tr>
            <tr>
                <td>3</td>
                <td>
                  <p><b>Calendaring Class</b></p>
                  <p>Using this class, you can dynamically create calendars.</p>
                </td>
            </tr>
            <tr>
                <td>4</td>
                <td>
                  <p><b>Shopping Cart Class</b></p>
                  <p>Using this class, you can add or remove item from Shopping Cart. The items are saved in session and will remain active
                  until the user is browsing the site.</p>
                </td>
            </tr>
            <tr>
                <td>5</td>
                <td>
                  <p><b>Config Class</b></p>
                  <p>Configuration preferences can be retrieved, using this class. This class is initialized automatically.</p>
                </td>
            </tr>
            <tr>
                <td>6</td>
                <td>
                  <p><b>Email Class</b></p>
                  <p>ამ კლასს აქვს ელ_ფოსტასთან დაკავშირებული ფუნქციები, გაგზავნა, პასუხი და ა.შ.</p>
                </td>
            </tr>
            <tr>
                <td>7</td>
                <td>
                  <p><b>Encryption Class</b></p>
                  <p>This class provides two-way data encryption functionality.</p>
                </td>
            </tr>
            <tr>
                <td>8</td>
                <td>
                  <p><b>File Uploading Class</b></p>
                  <p>ამ კლასს აქვს ფაილის ატვირთვასტან დაკავშირებული ფუნქციები.</p>
                </td>
            </tr>
            <tr>
                <td>9</td>
                <td>
                  <p><b>Form Validation Class</b></p>
                  <p>კლასს აქვს ფუნქციები, რომლებიც გამოიყენება ფორმის ვალიდაციისათვის.</p>
                </td>
            </tr>
            <tr>
                <td>10</td>
                <td>
                  <p><b>FTP Class</b></p>
                  <p>This class provides various FTP related functions like transferring files to remove server, moving, renaming or deleting files
                  on server.</p>
                </td>
            </tr>
            <tr>
                <td>11</td>
                <td>
                  <p><b>Image Manipulation Class</b></p>
                  <p>სურათებით მანიპულირება ზომის შეცვლა, მინიატურების შექმნა, დაკროპვა, ამობრუნება< და ა.შ</p>
                </td>
            </tr>
            <tr>
                <td>12</td>
                <td>
                  <p><b>Input Class</b></p>
                  <p>This class pre-processes the input data for security reason.</p>
                </td>
            </tr>
            <tr>
                <td>13</td>
                <td>
                  <p><b>Language Class</b></p>
                  <p>This class is used for internationalization.</p>
                </td>
            </tr>
            <tr>
                <td>14</td>
                <td>
                  <p><b>Loader Class</b></p>
                  <p>This class loads elements like View files, Drivers, Helpers, Models etc.</p>
                </td>
            </tr>
            <tr>
                <td>15</td>
                <td>
                  <p><b>Migrations Class</b></p>
                  <p>This class provides functionalities related to database migrations.</p>
                </td>
            </tr>
            <tr>
                <td>16</td>
                <td>
                  <p><b>Output Class</b></p>
                  <p>ეს კლასის ბრაუზერს უგზავნის გამოსატან ინფორმაციას და აგრეთვე ახდენს გვერდის კეშირებას.</p>
                </td>
            </tr>
            <tr>
                <td>17</td>
                <td>
                  <p><b>Pagination Class</b></p>
                  <p>This class adds pagination functionalities to web page.</p>
                </td>
            </tr>
            <tr>
                <td>18</td>
                <td>
                  <p><b>Template Parser Class</b></p>
                  <p>The Template Parser Class can perform simple text substitution for pseudo-variables contained within your view files. It can parse
                  simple variables or variable tag pairs.</p>
                </td>
            </tr>
            <tr>
                <td>19</td>
                <td><p><b>Security Class</b></p>
                <p>This class contains security related functions like XSS Filtering, CSRF etc.</p></td>
            </tr>
            <tr>
                <td>20</td>
                <td><p><b>Session Library</b></p>
                <p>ეს კლასი გვეხმარება გამოვიყენოთ სესიები ჩვენს აპლიკაციაში.</p></td>
            </tr>
            <tr>
                <td>21</td>
                <td><p><b>HTML Table</b></p>
                <p>ეს კლასი გამოიყენება მასივის ან მბ-დან მიღებული ინფორმაციის საფუძველზე HTML ცხრილის ავტოგენერირებისათვის.</p></td>
            </tr>
            <tr>
                <td>22</td>
                <td><p><b>Trackback Class</b></p>
                <p>The Trackback Class provides functions that enable you to send and receive Trackback data.</p></td>
            </tr>
            <tr>
                <td>23</td>
                <td><p><b>Typography Class</b></p>
                <p>ამ კლასსის მეთოდები გვეხმარება ტექსტის ფორმატირებაში..</p></td>
            </tr>
            <tr>
                <td>24</td>
                <td><p><b>Unit Testing Class</b></p>
                <p>This class provides functionalities to unit test your application and generate the result.</p></td>
            </tr>
            <tr>
                <td>25</td>
                <td>
                  <p><b>URI Class</b></p>
                  <p>ამ კლასს აქვს მეთოდები, რომელთა საშუალებითაც შესაძლებელია URI სტრიქონებიდან ინფორმაციის ამოღება. თუ ვიყენებთ URI მარშრუტიზაციას,
                  აგრეთვე შესაძლებელია URI სეგმენტების შესახებ ინფორმაციის მიღებაც.</p>
                </td>
            </tr>
            <tr>
                <td>26</td>
                <td><p><b>User Agent Class</b></p>
                <p>
                  ამ კლასის მეშვეობით შეიძლება დავადგინოთ ინფორმაცია ბრაუზერის, მობილური მოწყობილობის, ან ვებ-გვერდზე შემოსული ბოტების შესახებ.
                </p>
              </td>
            </tr>
            <tr>
                <td>27</td>
                <td>
                  <p><b>XML-RPC and XML-RPC Server Classes</b></p>
                  <p>CodeIgniter’s XML-RPC classes permit you to send requests to another server, or set up your own XML-RPC server to receive requests.</p>
                </td>
            </tr>
            <tr>
                <td>28</td>
                <td>
                  <p><b>Zip Encoding Class</b></p>
                  <p>ეს კლასი გამოიყენება მონაცემთა zip არქივების შესაქმნელად.</p>
                </td>
            </tr>
            </table>



      </dd>

      <dt>9. CI - URL მარშრუტიზაცია</dt>
      <dd class='answer'>

        როგორც ადრე აღვნიშნეთ CI-ს აქვს ადამიანისათვის გასაგები URL მისამართების მხარდაჭერა (რუს: ЧПУ - человекопонятный URL, ინგლ: friendly URL,
        მაგ: /product/phone/Samsung/), როგორც წესი მჭიდრო კავშირი და ერთი-ერთში მსგავსებაა URL ჩანაწერსა და მისი შესაბამისი  კონტროლერების
        კლასებისა და მეთოდების დასახელებებს შორის. სტანდარტული URI სეგმენტების შაბლონი ასეთია
        <code>
          your-domain.com/class/function/id/
        </code>
        <ul>
          <li>
            <b>პირველი სეგმენტი</b> -  განსაზღვრავს კონტროლერის კლასის დასახელებას რომელიც უნდა გაეშვას.
          </li>
          <li>
            <b>მეორე სეგმენტი</b> - განსაზღვრავს კლასის მეთოდს, ფუნქციას რომლის გამოძახებაც უნდა მოხდეს.
          </li>
          <li>
            <b>მესამე</b> და კიდევ დამატებითი სეგმენტები განსაზღვრავენ ID-ს და სხვა ცვლადებს, რომლებიც უნდა გადაეცეს კონტროლერს.
          </li>
        </ul>
        არის შემთხვევები, როდესაც საჭიროა მარშრუტიზაციის ამ მექანიზმის შეცვლა,  CI საშუალებას გვაძლევს განვსაზღვროთ მარშრუტიზაციის საკუთარი
        წესები.
        მაგალითად გვსურს შემდეგნაირი URL მისამართების გამოყენება
        <code>
          example.com/product/1/ <br />
          example.com/product/2/ <br />
          example.com/product/3/ <br />
          example.com/product/4/
        </code>
        ამ მისამართების მეორე სეგმენტებში კლასის მეთოდის ნაცვლად გამოყენებულია ID პარამეტრები. ამ შემთხვევაში საჭიროა მარშრუტიზაციის ახალი წესების
        განსაზღვრა.

        <h2>სამომხმარებლო მარშრუტები</h2>

        არსებობს კონკრეტული ფაილი რომელშიც შესაძლებელია საკუთარი მარშრუტების განსაზღვრა, ეს ფაილია - <b>application/config/routes.php.</b>
        ფაილში აღწერილია მასივი სახელად <b>$route</b> რომელშიც შესაძლებელია მარშრუტიზაციის საკუთარი წესების შეტანა, ამ მასივის გასაღები/მნიშველობა
        წყვილებიდან გასაღები გასაღები წყვეტს თუ რისი მარშრუტიზაციაა საჭირო, მნიშვნელობა კი წყვეტს თუ საით უნდა მიიმართოს მარშრუტი,
        მარშრუტის განსაზღვრა შესაძლებელია <b>ჩანაცვლების სიმბოლოებით (wildcards)</b> ან <b>რეგულარული გამოსახულებებით</b>. მაგრამ უნდა
        გავითვალისწინოთ, რომ ჩვენს მიერ შედგენილი მარშრუტიზაციის წესები უნდა აღიწეროს CI-ს რეზერვირებული წესების შემდეგ.

        <h2>ჩანაცვლების სიმბოლოები (wildcards)</h2>

        შესაძლებელია ორი სახის ჩანაცვლების სიმბოლოების გამოყენება
        <ul>
          <li><b>(:num)</b> - აღიქვამს მხოლოდ რიცხვების შემცველ სეგმენტს.</li>
          <li><b>(:any)</b> - აღიქვამას სხვადასხვა სიმბოლოების შემცველ სეგმენტს.</li>
        </ul>

        ჩანაცვლების სიმბოლოების შემცველი მარშრუტი შეიძლება გამოიყურებოდეს შემდეგნაირად
        <code>
          $route['product/:num'] = 'catalog/product_lookup';
        </code>
        ანუ თუ URL მისამართის პირველ სეგმენტში მოიძებნება სიტყვა "product", ხოლო მეორე სეგმენტში კი რიცხვი, მაშინ ჩაიტვირთება  კლასი "catalog" და
        მეთოდი "product_lookup".

        <h2>მაგალითები</h2>

        <code>
          $route['journals'] = 'blogs';
        </code>

        URL მისამართი რომელიც პირველ სეგმენტში შეიცავს სიტყვას -  “journals” გადამისამართდება “blogs” კლასისკენ.

        <code>
          $route['blog/joe'] = 'blogs/users/34';
        </code>

        URL მისამართი რომელიც შეიცავს blog/joe სეგმენტებს გადამისამართდება “blogs” კლასისა და მისი “users” მეთოდისაკენ. ID პარამეტრის მნიშვნელობა კი
        იქნება “34”.

        <h2>რეგულარული გამოსახულებები</h2>

        <b>$route</b> მასივის გასაღებად შესაძლებელია რეგულარული გამოსახულებების გამოყენებაც, თუ URI დაემთხვევა რეგულარულ გამოსახულებას
        მაშინ მარშრუტი წარემართება $route მასივის ამ გასაღების შესაბამის მნიშვნელობაში მითითებული მისამართისკენ.
        <code>
          $route['products/([a-z]+)/(\d+)'] = '$1/id_$2';
        </code>
        ამ მაგალითის მიხედვით თუ URL მისამართს ექნება დაახლოებით ამგვარი სახე - "products/shoes/123", გამოძახებულ იქნება კლასი “shirts”  და
        მეთოდი  “id_123”.


        <h2>რეზერვირებული მარშრუტები</h2>

        CI-ში არის
       სამი რეზერვირებული მარშრუტი
       <table class="table table-bordered">
         <tr>
           <th>N</th>
           <th style="text-align:center;">მარშრუტის აღწერა</th>
         </tr>
         <tr>
           <td>1</td>
           <td><p><b>$route['default_controller']</b></p>
           <p>
             ეს მარშრუტი განსაზღვრავს თუ რომელი კონტროლერის კლასი  უნდა ჩაიტვირთოს იმ შემთხვევაში, როდესაც URI არ შეიცავს იმ კონკრეტულ
             ინფორმაციას, რომელმაც უნდა განსაზღვროს  თუ რა ჩაიტვირთოს ძირითადი URI-ის გახსნისას. რეკომენდებულია გვქონდეს მარშუტი, რპმელიც
             ნაგულისმეობის პრინციპით ჩატვირთავს რომელიმე კლასს გვედის გახსნისას, წინააღმდეგ შემთხვევაში გაიხსნება 404 გვერდი ანუ ინფორმაცია
             ვერ მოიძებნება, როგორც წესი აქ უნდა მივუთითოთ პროექტის მთავარი გვერდი რათა ის გაიხსნას გვერდზე შესვლისას.
           </p>
         </td>
         </tr>
         <tr>
           <td>2</td>
           <td><p><b>$route['404_override']</b></p>
           <p>
             ეს მარშრუტი განსაზღვრავს თუ რომელი კონტროლერის კლასი უნდა ჩაიტვირთოს თუ მოთხოვნილი კონტროლერი ვერ მოიძებნენა, ამ მარშრუტში
             განსაზღრული კლასი გადაფარავს 404 შეცდომის შეტყობინების გვერდს. ეს გავლენას არ მოახდენს <b>show_404()</b> ფუნქციის მუშაობაზე, რომელიც
             გააგრძელებს ნაგულისხმეობის პრინციპით ფაილის ჩატვირთვას <b>application/views/errors/error_404.php.</b>
           </p>
         </td>
         </tr>
         <tr>
           <td>3</td>
           <td><p><b>$route['translate_uri_dashes']</b></p>
           <p>
             როგორც ლოგიკური მნიშვნელობიდან ჩანს ეს მარშრუტი არ არის,  ეს თვისება საშუალებას გვაძლევს URL-ის სეგმენტებში არსებული ტირეები:
             "-", ავტომატურად შეიცვალოს ქვედა ტირეებით "_",  ამის გაკეთება აუცილებელია რადგან ტირე არ ითვლება კლასის ან მეთოდის სახელში
             დასაშვებ სიმბოლოდ, და მისი URL-ში მოხვედრა გამოიწვევს <b>Fatal</b> ტიპის შეცდომას.
           </p>
         </td>
         </tr>
       </table>


      </dd>

      <dt>10. CI - ალტერნატიული PHP სინტაქსი</dt>
      <dd class='answer'>

        შესაძლებელია მოხდეს ისე, რომ წარმოდგენის ფაილში დაგვჭირდეს PHP კოდის გამოყენება. იმისათვის რათა წარმოდგენის ფაილში გჰამოვიყენოთ PHP კოდის
        მინიმალური რაოდენობა და კოდის ბლოკების იდენტიფიკაციაც მარტივი იყოს, რეკომენდებულია PHP-S ალტერნატიული სინტაქსის გამოყენება.

        <h2>ალტერნატიული ECHO</h2>

        როგორც წესი, echo ოპერატორით ცვლადის გამოტანის სინტაქსი შემდეგნაირია
        <code>
          &lt;?php echo $variable; ?>
        </code>
        ალტერნატიული სინტაქსი კი ასეთი
        <code>
          &lt;?=$variable?>
        </code>


        <h2>საკონტროლო სტრუქტურების ალტერნატივები</h2>

        საკონტროლო სტრუქტურების (if, for, foreach და while) ჩაწერის ალტერნატიული ვარიანტი მოვიყვანოთ foreach ციკლის მაგალითზე
        <code>
          <pre>
&lt;ul>

&lt;?php foreach ($todo as $item): ?>

        &lt;li>&lt;?=$item?>&lt;/li>

&lt;?php endforeach; ?>

&lt;/ul>
          </pre>
        </code>
        შევნიშნოთ, რომ არ ხდება ფიგურული ფრჩხილების გამოყენება, დამხურავი ფიგურული ფრჩხილი ჩანაცვლებულია <b>endforeach</b>-ით. შესაბამისად
        სხვა საკონტროლო სტრუქტურების დამხურავი ელემენტებია <b>endif, endfor, endforeach და endwhile</b>.
        <p>
          აგრეთვე შევნიშნოთ, რომ ჩანაწერების შემდეგ (გარდა ბოლო ჩანაწერისა), წერტილ-მძიმის ნაცვლად გამოყენებულია ორწერტილი.
        </p>
        <code>
          <pre>
&lt;?php if ($username === 'sally'): ?>

        &lt;h3>Hi Sally&lt;/h3>

&lt;?php elseif ($username === 'joe'): ?>

        &lt;h3>Hi Joe&lt;/h3>

&lt;?php else: ?>

        &lt;h3>Hi unknown user&lt;/h3>

&lt;?php endif; ?>          </pre>
        </code>

      </dd>


      <dt>11. CI - უსაფრთხოება</dt>
      <dd class='answer'>

        <h2>URL უსაფრთხოება</h2>

        CI-ში საკმაოდ მკაცრადაა განსაზღვრული იმ სიმბოლოთა რაოდენობა, რომლებიც შესაძლებელია, რომ მოხვდნენ URL მისამართებში, ეს გაკეთებულია
        ბოროტად განწყობილი მომხმარებლების მიერ, ჩვენს აპლიკაციაში არასასურველი და სახიფათო ინფორმაციის შეყვანის აღკვეთის მიზნით, URL მისამართში
        შეიძლება შევიდეს მხოლოდ
        <ul class="simple">
            <li>ლათინური ანბანის ასოები და ციფრები</li>
            <li>კლაკნილი ხაზი: ~</li>
            <li>პროცენტის ნიშანი: %</li>
            <li>წერტილი: .</li>
            <li>ორწერტილი: :</li>
            <li>ქვედა ტირე: _</li>
            <li>ტირე: -</li>
            <li>გამოტოვებული ადგილი (space)</li>
        </ul>

        <h2>შეცდომების გამოტანა</h2>

        როდესაც პროექტი გაშვებულია ქსელში ანუ როცა მასზე მუშაობა უკვე დასრულებულია, სასურველია, რომ PHP-ს შეცდომების შეტყობინების ფუნქცია
        გამორთული  იყოს. ამ შემთხვევაში აღარ მოხდება დაშვებული შეცდომების შეტყობინებების ეკრანზე გამოტანა, რომლებიც შეიძლება შეიცავდნენ
        კონფიდენციალურ ინფორმაციას.
        <p>
          სხვა ვითარებაა პროექტის დამზადების პროცესში, ამ შემთხვევაში შეცდომების გამოტანა უფრო კომფორტულს ხდის მუშაობის პროცესს, რადგან
          დაუყოვნებლივ ხვდებით თუ სად რა შეცდომა გაიპარა.
        </p>

        <h2>საუკეთესო პრაქტიკა</h2>

        მანამ სანამ დავთანხმდებით, რომ ესა თუ ის ინფორმაცია გადაეცეს აპლიკაციას (მაგ: POST მეთოდით ფორმიდან გამოგზავნილი ინფორმაცია) სასურველია
        ამ ინფორმაციამ გაიაროს შემდეგი საფეხურები
        <ol>
          <li>ვალიდაცია (სწორია თუ არა ტიპი, სიგრძე, ზომა და ა.შ)</li>
          <li>ფილტრი (ხომ არ შეიცავს არასასურველ სიმბოლოებს და ა.შ)</li>
          <li>გასუფთავება (თუ შეიცავს არასასურველ სიმბოლოებს წაიშაოლოს ეს სიმბოლოები)</li>
        </ol>

        <h2>ფორმის ელემენტებიდან აკრეფილი ინფორმაციის ვალიდაცია</h2>

        ფორმის ელემენტებიდან აკრეფილი ინფორმაციის ვალიდაციისათვის CI-ს აქვს ფორმის ვალიიდციის ბიბლიოთეკა. თუ მოხდა ისე რომ არ ვიყენებთ ამ
        ბიბლიოთეკას მაშინ ეს უნდა გავაკეთოთ სხვა ხერხებით.  მაგალითად თუ შესაყვან ველში აკრეფილი ინფორმაცია უნდა იყოს რიცხვითი ტიპის, შეგვიძლია
        გამოვიყენოთ ფუნქციები <b>is_numeric() ან ctype_digit()</b>.

        <h2>ფაილების დამალვა</h2>

        უსაფრთხოების კიდევ ერთი კარგი პრაქტიკაა, რომ ჩვენი index.php ფაილი და სხვა ძირითადი ფაილები (მაგ .js, css და ა.შ)  დავტოვოთ პროექტის
        ძირითად საქაღალდეში (ხშირ შემთხვევაში მას ჰქვია htdocs/”). ეს ის ფაილებია, რომელთა მიღებაც დაგვჭირდება ინტერნეტიდან.

        <p>
          არ არის სასურველი მომხმარებელს მიეცეს შესაძლებლობა ნახოს ისეთი ფაილები და საქაღალდეები რომლების ნახვაც არ არის საჭირო და აუცილებელი.
        </p>
        <p>
          ასეთი ფაილების და საქაღალდეების დასამალად შესაძლებელია .htaccess ფაილის გამოყენებაც.
        </p>


      </dd>

      <dt>12. CI - PHP კოდის სტილი</dt>
      <dd class='answer'>

        <h2>ფაილთა დასახელებები</h2>

        კლასების შემცველი ფაილების დასახელებები უნდა დაიწყოს დიდი ასოთი, მაშინ როდესახ სხვა ფაილების (კონფიგურაციული, წარმოდგენა და ა.შ)
        დასახელებები უნდა ჩაიწეროს ჩვეულებრივად - პატარა ასოებით.

        <h3>არასწორია</h3>

        <code>
          somelibrary.php<br />
          someLibrary.php<br />
          SOMELIBRARY.php<br />
          Some_Library.php<br /><br />

          Application_config.php<br />
          Application_Config.php<br />
          applicationConfig.php
        </code>

        <h3>სწორია</h3>

        <code>
          Somelibrary.php<br />
          Some_library.php<br /><br />

          applicationconfig.php<br />
          application_config.php
        </code>
        გარდა ამისა, კლასის ფაილების დასახელებები უნდა დაემთხვეს თავად კლასის დასახელებებს, მაგალითად თუ გვაქვს კლასი "Myclass", მის შესაბამის ფაილს
        უნდა დავარქვათ "Myclass.php".


        <h2>კლასთა და ფაილთა დასახელებები</h2>

        კლასთა დასახელებები უნდა დაიწყოს დიდი ასოთი, დასახელებაში სხვადასხვა სიტყვები ერთმანეთისაგან უნდა გამოიყოს ქვედა ტირეთი და არა აქლემისებური
        სტილის მეშვეობით (CamelCase).

        <h3>არასწორია</h3>

        <code>
          class superclass<br />
          class SuperClass
        </code>

        <h3>სწორია</h3>

        <code>
          class Super_class
        </code>

        კლასის მეთოდის დასახელება უნდა ჩაიწეროს პატარა ასოებით და ისე უნდა განისაზღროს რომ მკაფიოდ მიუთითებდეს და ასოცირდებოდეს თავად მეთოდის
        ფუნქციონალიტეტთან, შინაარსთან. არაა სასურველი მეთოდის სახელი იყოს ძალიან გრძელი და შეიცავდეს ბევრ სიტყვებს. სახელში შემავალი სიტყვები
        ერთმანეთისაგან უნდა გამოიყოს ქვედა ტირით.

        <h3>არასწორია</h3>

        <code>
          function fileproperties()               // არ აღწერს მეთოდის შინაარს და აკლია სიტყვათა გამომყოფი <br />
          function fileProperties()               // არ აღწერს მეთოდის შინაარს და ჩაწერილია აქლემისებური სტილით<br />
          function getfileproperties()            // უკეთესია !  მაგრამ აკლია სიტყვათა გამომყოფი<br />
          function getFileProperties()            // ჩაწერილია აქლემისებური სტილით<br />
          function get_the_file_properties_from_the_file()        // სიტყვაგრძელია
        </code>

        <h3>სწორია</h3>

        <code>
          /* <br />
          &nbsp; &nbsp;აღწერს მეთოდის შინაარს,<br />
          &nbsp; &nbsp;მითითებულია გამომყოფი,<br />
          &nbsp; &nbsp;ჩაწერილია პატარა ასოებით<br />
          */<br />
          function get_file_properties()
        </code>


        <h2>ცვლადთა დასახელებები</h2>

        ცვლადთა დასახელების შექმნის რეკომენდაციები წააგავს კლასთა მეთოდების დასახელების შექმნის რეკომენდაციებს. ცვლადის დასახელება უნდა შეიცავდეს
        მხოლოდ პატარა ასოებს, მასში შემავალი სიტყვები უნდა გამოიყოს ქვედა ტირით, და შინაარსობივად უნდა მიგვანიშნებდეს თავად ცვლადის დანიშნულებისაკენ.
        ძალიან მოკლე და არასიტყიერი ცვლადები უნდა გამოვიყენოთ მხოლოდ for() ტიპის ციკლების იტერაციების დასათვლელად.

        <h3>არასწორია</h3>

        <code>
          $j = 'foo';             // ერთასოიანი დასახელება  for() ციკლის გარეთ<br />
          $Str                    // შეიცავს დიდ ასოებს<br />
          $bufferedText           // იყენებს აქლემისებურ სტილს, შესაძლებელია უფრო მოკლედ ჩაწერაც<br />
          $groupid                // რამოდენიმე სიტყვა გამყოფის გარეშე<br />
          $name_of_last_city_used // გრძელი დასახელება
        </code>

        <h3>სწორია</h3>

        <code>
          for ($j = 0; $j < 10; $j++)<br />
          $str<br />
          $buffer<br />
          $group_id<br />
          $last_city
        </code>

        <h2>კომენტარები კოდში</h2>

        კომენტარები კოდში, ეხმარება არა მარტო ნაკლებად გამოცდილ პროგრამისტს, არამედ შესაძლებელია ჩვენთვისაც ძალიან მნიშვნელოვანი აღმოჩნდეს
        რამოდენიმე თვის შემდეგ საკუთარი კოდის ნახვისას. "DocBlock" სტილის კომენტარების გამოყენება მიზანშეწონილია კლასების, მეთოდების და თვისებების
        აღწერისას.
        <code>
          <pre>
/**
 * Super Class
 *
 * @package     Package Name
 * @subpackage  Subpackage
 * @category    Category
 * @author      Author Name
 * @link        http://example.com
*/
class Super_class {
          </pre>
        </code>

        ერთხაზიანი კომენტარების გამოყენებისას სასურველია კომენტარის ბლოკებს შორის დავამატოთ გამოტოვებული ხაზები
        <code>
          <pre>
// break up the string by newlines
$parts = explode("\n", $str);

// A longer comment that needs to give greater detail on what is
// occurring and why can use multiple single-line comments.  Try to
// keep the width reasonable, around 70 characters is the easiest to
// read.  Don't hesitate to link to permanent external resources
// that may provide greater detail:
//
// http://example.com/information_about_something/in_particular/

$parts = $this->foo($parts);
          </pre>
        </code>

        <h2>კონსტანტები</h2>

        კონსტანტების დასახელების შექმნის რეკომენდაციები წააგავს ცვლადთა დასახელების შექმნის რეკომენდაციებს, იმ განსხვავებით რომ კონსტანტების სახელები
        უნდა ჩაიწეროს დიდი ასოებით.

        <h3>არასწორია</h3>

        <code>
          myConstant      // არ არის ჩაწერილი დიდი ასოებით <br />
          N               // ჩაწერილია ერთი ასოთი<br />
          S_C_VER         // არ აღწერს შინაარსს, დანიშნულებას<br />
        </code>

        <h3>სწორია</h3>

        <code>
          MY_CONSTANT<br />
          NEWLINE<br />
          SUPER_CLASS_VERSION<br />
        </code>

        <h2>TRUE, FALSE და NULL</h2>

        TRUE, FALSE და NULL სიტყვა გასაღებები ყოველთვის უნდა ჩაიწეროს დიდი ასოებით.

        <h3>არასწორია</h3>

        <code>
          if ($foo == true)<br />
          $bar = false;<br />
          function foo($bar = null)
        </code>

        <h3>სწორია</h3>

        <code>
          if ($foo == TRUE)<br />
          $bar = FALSE;<br />
          function foo($bar = NULL)
        </code>


        <h2>ლოგიკური ოპერატორები</h2>

        "ან" ოპერატორის ჩასაწერად "||" ჩანაწერის გამოყენება არ არის რეკომენდებული, რადგან ზოგიერთ მოწყობილობაში შეიძლება იგი არ გამოჩნდეს კარგად
        და მიემგვანოს რიცხვ 11-ს. "და" ლოგიკური ოპერატორის ჩასაწერად სასურველია გამოვიყენოთ "&&" ჩანაწერი, ხოლო "არა" ოპერატორის "!" სიმბოლოთი
        ჩაწერისას ამ სიმბოლოსთან უნდა დავტოვოთ გამოტოვებული ადგილები.

        <h3>არასწორია</h3>

        <code>
          if ($foo || $bar)<br />
          if ($foo AND $bar)  <br />
          if (!$foo)<br />
          if (! is_array($foo))
        </code>

        <h3>სწორია</h3>

        <code>
          if ($foo OR $bar)<br />
          if ($foo && $bar) // recommended<br />
          if ( ! $foo)<br />
          if ( ! is_array($foo))
        </code>


        <h2>დასაბრუნებელი მნიშვნელობების ტოლობები</h2>

        ზოგიერთი  PHP ფუნქცია წარუმატებლობის შემთხვევაში აბრუნებს მნიშვნელობას - FALSE, მაგრამ აგრეთვე შესაძლებელია მიიღოს მნიშვნელობა " " ან
        0, რომლებიც აღიქმება როგორც FALSE, პირობების არასწორად მითითების შემთხვევაში. პირობების განსაზღვრა ისე უნდა მოხდეს რომ გარანტირებულები
        ვიყოთ შედეგის დაბრუნებისას, ამისავის უნდა გამოვიყენოთ  "===" და "!=="ოპერატორები.

        <h3>არასწორია</h3>

        <code>
          // თუ 'foo' გვხვდება სტრიქონის დასაწყისში, strpos დააბრუნებს 0-ს, <br />
          // ლოგიკური პირობის მნიშვნელობა შეფასდება როგორც TRUE <br />
          if (strpos($str, 'foo') == FALSE)
        </code>

        <h3>სწორია</h3>

        <code>
          if (strpos($str, 'foo') === FALSE)
        </code>

        <h3>არასწორია</h3>

        <code>
          <pre>
function build_string($str = ""){
        if ($str == "") // მაგრამ რა მოხდება თუ FALSE ან 0 გადაიცემა არგუმენტად ?
        {

        }
}
          </pre>
        </code>


        <h3>წორია</h3>

        <code>
          <pre>
function build_string($str = ""){
        if ($str === "")
        {

        }
}
          </pre>
        </code>



        <h2>ბრჭყალები და ფრჩხილები</h2>

        როგორც წესი ბრჭყალებისა და ფრჩხილების ირგვლივ გამოტოვებული ადგილების დატოვება არ არის საჭირო, გამონაკლისია PHP-ს სტრუქტურული
        მმართველების (do-while, elseif, for, foreach, if, switch, while) ჩაწერა, რომლებიც არგუმენტებს იღებენ მრგვალი ფრჩხილების საშუალებით,
        და ამ ფრჩხილებში ადგილის გამოტოვება უფრო ადვილად წასაკითხს ხდის კოდს.

        <h3>არასწორია</h3>

        <code>
            $arr[ $foo ] = 'foo';
        </code>


        <h3>წორია</h3>

        <code>
            $arr[$foo] = 'foo'; // მასივის გასაღების ირგვლივ არაა საჭირო ადგილების გამოტოვება
        </code>

        <h3>არასწორია</h3>

        <code>
          <pre>
function foo ( $bar ){

}
          </pre>
        </code>


        <h3>წორია</h3>

        <code>
          <pre>
function foo($bar){

}
          </pre>
        </code>

        <h3>არასწორია</h3>

        <code>
          foreach( $query->result() as $row )
        </code>


        <h3>წორია</h3>

        <code>
          foreach ($query->result() as $row)
        </code>


        <h2>ერთი ჩანაწერი ერთ ხაზზე</h2>

        <h3>არასწორია</h3>

        <code>
          $foo = 'this'; $bar = 'that'; $bat = str_replace($foo, $bar, $bag);
        </code>


        <h3>წორია</h3>

        <code>
          $foo = 'this';  <br />
          $bar = 'that';  <br />
          $bat = str_replace($foo, $bar, $bag);
        </code>


        <h2>სტრიქონები</h2>

        სტრიქონების ჩაწერისას ყოველთვის უნდა გამოვიყენოთ ერთმაგი, ჩვეულებრივი ბრჭყალები თუ სტრიქონში არ არის ჩართული რაიმე ცვლადი, ხოლო თუ
        ცვლადი ჩართულია მაშინ სტრიქონი უნდა ჩავსვათ ორმაგ ბრჭყალებში, ხოლო თავად ცვლადი - ფიგურული ფრჩხილებში.

        <h3>არასწორია</h3>

        <code>
          "My String"        // არ გვაქვს ცვლადი სტრიქონში <br />
          "My string $foo"        // ცვლადი არ ზის ფიგურულ ბრჩხილებში <br />
          'SELECT foo FROM bar WHERE baz = \'bag\''
        </code>


        <h3>წორია</h3>

        <code>
          'My String' <br />
          "My string {$foo}" <br />
          "SELECT foo FROM bar WHERE baz = 'bag'"
        </code>


        <h2>SQL მოთხოვნები</h2>

        SQL სიტყვა გასაღებები ყოველთვის იწერება დიდი ასოებით : SELECT, INSERT, UPDATE, WHERE, AS, JOIN, ON, IN და ა.შ. თუ მოთხოვნის ტექსტი საკმაოდ
        გრძელია სასურველია მისი ფრაგმენტები განვათავსოთ ახალ ხაზებზე.

        <h3>არასწორია</h3>

        <code>
          <pre>
// სიტყვა გასაღებები პატარა ასოებითაა ჩაწერილი
// და მოთხოვნაც გრძელია ერთ ხაზზე ჩასაწერად
$query = $this->db->query("select foo  as raboof, foobaz from exp_pre_email_addresses
...where foo != 'oof' and baz != 'zab' order by foobaz limit 5, 100");
          </pre>
        </code>


        <h3>წორია</h3>

        <code>
          <pre>
$query = $this->db->query("SELECT foo AS raboof, foobaz
                                FROM exp_pre_email_addresses
                                WHERE foo != 'oof'
                                AND baz != 'zab'
                                ORDER BY foobaz
                                LIMIT 5, 100");
          </pre>
        </code>


      </dd>

      <dt>13. CI - კონფიგურაცია</dt>
      <dd class='answer'>

        <b>application/config</b> საქაღალდე შეიცავს ფაილებს რომლებშიც უნდა განვსაზღვროთ ჩვენი საიტის ძირითადი კონფიგურაციული პარამეტრები.

        <h2>საბაზისო URL მისამართის განსაზღვრა</h2>

        საბაზისო URL მისამართის განსაზღვრა შესაძლებელია <b>application/config/config.php</b> ფაილში, საბაზისო URL არის  ჩვენი CI პროექტის
        ძირის მისამართი
        <code>
          http://example.com/
        </code>
        თუ საბაზისო URL მითითებული არ არის CI შეეცდება გამოიცნოს პროტოკოლი, დომეინი და გზა ჩვენს აპლიკაციამდე, ასეა თუ ისე ეს პარამეტრი
        ყოველთვის უნდა განცსაზღვროთ,  განსაკუთრებით მაშინ როცა პროექტი უკვე გაშვებულია სამუშაო გარემოში. საბაზისო URL-ის განსაზღვრა
        შესაძლებელია <b>$config</b> მასივში <b>base_url</b> გასაღების მეშვეობით
        <code>
          $config['base_url'] = 'http://your-domain.com';
        </code>

        <h2>მონაცემთა ბაზის კონფიგურაცია</h2>

        მონაცემთა ბაზის კონფიგურაციაზე ვისაუბრებთ "CI - მონაცემთა ბაზასთან მუშაობა" განყოფილების მე-2-ე თავში.



        <h2>ავტომატური ჩატვირთვის კონფიგურაცია</h2>

        ავტომატური ჩატვირთვის კონფიგურაციული პარამეტრების განსაზღვრა ხდება ფაილში <b>application/config/autoload.php</b>. ეს ფაილი
        განსაზღვრავს რომელი  სისტემები უნდა ჩაიტვირთოს ავტომატურად, იმისათვის რათა სტრუქტურა მასიმალურად გამარტივდეს, ნაგულისმეობის
        პრინციპით ხდება აბსოლიტურად  მინიმალური რესურსების ჩატვირთვა.

        <ul>
          <li>
            <b>Libraries</b> - ეს არის ბიბლიოთეკების სია რომლებიც ავტომატურად ჩაიტვირთება CI-ს მიერ. ამისათვის ეს ბიბლიოთეკები უნდა
            მოთავსდეს მასივში,   მაგალითად ჩავტვირთოთ database, email და session ბიბლიოთეკები
          </li>
        </ul>
        <code>
          $autoload['libraries'] = array('database', 'email', 'session');
        </code>

        <ul>
          <li>
            <b>Helper files</b> - ეს არის დამხმარე ფაილების სია რომლებიც ავტომატურად ჩაიტვირთება CI-ს მიერ. ამისათვის ამ ფაილთა დასახელებები
            უნდა მოთავსდეს  მასივში,  მაგალითად ჩავტვირთოთ URL და file  დამხმარე ფაილები.
          </li>
        </ul>
        <code>
          $autoload['helper'] = array('url', 'file');
        </code>

        <ul>
          <li>
            <b>Language files</b> - ეს არის ენის ფაილების სია რომლებიც ავტომატურად ჩაიტვირთება CI-ს მიერ. ამისათვის ამ ენათა დასახელებები
            უნდა მოთავსდეს  მასივში
          </li>
        </ul>
        <code>
          $autoload['language'] = array('lang1', 'lang2');
        </code>

      </dd>

      </dl>
  </div>


  <BR><BR>

  <div class="content">
      <h2 style="margin-left: 25px;">CI - დამხმარეები</h2>
  </div>

  <BR><BR>

  <div class="content">
      <dl class="faqs">


      <dt>1. CI - მასივის დამხმარე</dt>
      <dd class='answer'>

          მასივთან მუშაობისას გამოსაყენებელი დამხმარე ფუნქციების შემცველი ფაილის ჩატვირთვა ხდება შემდეგნაირად
          <code>
            $this->load->helper('array');
          </code>

          <h2>ხელმისაწვდომი ფუნქციები</h2>

          <h3>element()</h3>

          სინტაქსი ასეთია
          <code>
            element($item, $array[, $default = NULL])
          </code>

          <ul>
            <li><b>$item</b> - ელემენტი რომლის ამოღებაც გვსურს მასივიდან</li>
            <li><b>$array</b> - შესაბამისი მასივი</li>
            <li><b>$default</b> - რა დაბრუნდეს თუ ვერ მოიძებნება საჭირო პასუხი </li>
          </ul>
          ფუნქცია ადგენს აქვს თუ არა მასივს ესა თუ ის ინდექსი ან მითითებულია  თუ არა რომელიმე ინდექსის მნიშვნელობა. თუ მასივის გასაღების
          მნიშვნელობა არ არის მითითებულიფუნქცია, ფუნქცია აბრუნებს NULL-ს ან იმ მნიშვნელობას რასაც მესამე პარამეტრად მივუთითებთ.
          <code>
            <pre>
$array = array(
        'color' => 'red',
        'shape' => 'round',
        'size'  => ''
);

echo element('color', $array); // დაბრუნდება "red"
echo element('size', $array, 'foobar'); // დაბრუნდება "foobar"
            </pre>
          </code>

          <h3>elements()</h3>

          elements ფუნქციაც მუშაობს element ფუნქციის ანალოგიურად, უბრალოდ მისი დახმარებით შესაძლებელია რამოდენიმე ელემენტის ერთდროულად
          ამოღება.
          <code>
            <pre>
$array = array(
        'color' => 'red',
        'shape' => 'round',
        'radius' => '10',
        'diameter' => '20'
);

$my_shape = elements(array('color', 'shape', 'height'), $array);
            </pre>
          </code>
          შედეგი იქნება
          <code>
            <pre>
array(
        'color' => 'red',
        'shape' => 'round',
        'height' => NULL
);
            </pre>
          </code>
          შეგვიძლია მესამე პარამეტრის გადაცემაც
          <code>
            $my_shape = elements(array('color', 'shape', 'height'), $array, 'foobar');
          </code>
          შედეგი
          <code>
            <pre>
array(
        'color'         => 'red',
        'shape'         => 'round',
        'height'        => 'foobar'
);
            </pre>
          </code>
          elements ფუნქციის გამოყენება ეფექტურია როდესაც რომელიმე მოდელს ინფორმაცია ეგზავნება $_POST მასივით.
          <code>
            <pre>
  $this->load->model('post_model');
  $this->post_model->update(
          elements(array('id', 'title', 'content'), $_POST)
  );
            </pre>
          </code>
          ეს ჩანაწერი არ აძლევს მომხმარებელს საშუალებას გააგზავნოს ისეთი ინფორმაცია რომელიც არ უნდა შევიდეს ცხრილში, ანუ ამ შემთხვევაში
          ცხრილში  განახლდება  მხოლოდ  id, title და content ველები.


          <h2>random_element()</h2>

          ფუნქცია გამოიყენება მასივიდან შემთხვევითი ელემენტის ამოსაღებად.
          <code>
            random_element($array)
          </code>
          <code>
            <pre>
$quotes = array(
        "თბილისი",
        "ქუთაისი",
        "მცხეთა",
        "ბათუმი",
        "ცხინვალი",
        "სოხუმი"
);

echo random_element($quotes);
            </pre>
          </code>



      </dd>

      <dt>2. CI - ელ_ფოსტის დამხმარე</dt>
      <dd class='answer'>

        ელ_ფოსტის დამხმარე მოიცავს ფუნქციებს, რომლებიც გვეხმარებიან ელ_ფოსტასთან მუშაობისას, ჩატვირთვა ხდება  შემდეგნაირად
        <code>
          $this->load->helper('email');
        </code>

        <h3>valid_email()</h3>

        ამოწმებს არის თუ არა კორექტული ელ_ფოსტა პარამეტრად გადაცემული სტრიქონი. აბრუნებს TRUE/FALSE მნიშვნელობებს.
        <code>
          <pre>
if (valid_email('email@somesite.com')){
        echo 'email is valid';
}
else{
        echo 'email is not valid';
}
          </pre>
        </code>

        <h3>send_email()</h3>

        <code>
          send_email($recipient, $subject, $message)
        </code>
        ფუნქცია აბრუნებს TRUE/FALSE მნიშვნელობებს იმისდამიხედვით გაიგზავნა თუ არა ელ_ფოსტა.

      </dd>

      <dt>3. CI - ფაილების დამხმარე</dt>
      <dd class='answer'>

        ჩატვირთვა ხდება შემდეგნაირად
        <code>
          $this->load->helper('file');
        </code>

        <h3>file_get_contents()</h3>

        აბრუნებს ფაილის შიგთავსს ან FALSE-ს წარუმატებლობის შემთხვევაში, სინტაქსი ასეთია
        <code>
          $string = file_get_contents('./path/to/file.php');
        </code>
        ფაილამდე გზა აღიქმება და უნდა ჩაიწეროს ძირითადი ფაილის <b>index.php</b>-სთან მიმართებაში და არა კონტროლერებთან ან წარმოდგენებთან
        მიმართებაში,  CI იყენებს index.php ფაილს იყენებს როგორც მთავარ კონტროლერს და ამიტომ ბილიკები (pats) იწერება მასთან მიმართებაში.


        <h3>delete_files()</h3>

        შლის ყველა ფაილს მითითებულ საქაღალდეში სინტაქსი ასეთია
        <code>
          delete_files($path[, $del_dir = FALSE[, $htdocs = FALSE]])
        </code>
        $path პარამეტრი განსაზღვრავს თავად საქაღალდეს,  $del_dir პარამეტრი არის ლოგიკური ტიპის TRUE/FALSE და განსაზღვრავს წაიშალოს თუ
        არა დირექტორიაში  არსებული სხვა დირექტორიებიც, $del_dir პარამეტრიც არის ლოგიკური ტიპის TRUE/FALSE და განსაზღვრავს წაიშალოს თუ
        არა დირექტორიაში  არსებული .htaccess და index page ფაილები. მთლიანობაში ფუნქცია აბრუნებს TRUE/FALSE მნიშვნელობებს წარმატებიდან
        გამომდინარე
        <code>
          delete_files('./path/to/directory/');
        </code>

        <h3>get_file_info()</h3>

        აბრუნებს ინფორმაციას მითიტებული ფაილის შესახებ (სახელი, გზა ფაილამდე, ზომა განახლების თარიღი).
        <code>
          $file = 'somefile.png'; <br />
          echo get_file_info($file);
        </code>


      </dd>

      <dt>4. CI - ფორმების დამხმარე</dt>
      <dd class='answer'>

        ჩატვირთვის სინტაქსი
        <code>
          $this->load->helper('form');
        </code>

        <h3>form_open()</h3>

        ფუნქცია აბრუნებს HTML ფორმის გამხსნელ ტეგს. ფუნქციის სინტაქსი ასეთია
        <code>
          form_open([$action = ''[, $attributes = ''[, $hidden = array()]]])
        </code>
        $action პარამეტრი განსაზღვრავს ფორმის action ატრიბუტს, ანუ გვერდს სადაც უნდა გაიგზავნოს ინფორმაცია ფორმიდან, $attributes  პარამეტრი
        განსაზღვრავს HTML ატრიბუტებს, $hidden ატრიბუტი განსაზღვრავს დამალულ ველებს.
        <code>
          echo form_open('email/send');
        </code>
        ეს ჩანაწერი შექმნის ფორმის გამხსნელ ტეგს და ტოლფასია შემდეგი ჩანაწერისა
        <code>
          &lt;form method="post" accept-charset="utf-8" action="http://example.com/index.php/email/send">
        </code>

        <h3>ატრიბუტების დამატება</h3>

        ფორმის ატრიბუტების დასამატებლად, form_open() ფუნქციას მეორე პარამეტრად უნდა გადავცეთ ასოციაციური მასივი, რომელშიც თავმოყრილი იქნება
        ატრიბუტი/მნიშვნელობა წყვილები.
        <code>
          $attributes = array('class' => 'email', 'id' => 'myform'); <br />
          echo form_open('email/send', $attributes);
        </code>
        ამ ჩანაწერის ალტერნატიული ვარიანტი ატრიბუტების სტრიქონის სახით აღწერაა
        <code>
          echo form_open('email/send', 'class="email" id="myform"');
        </code>
        ორივე შემთხვევაში მივიღებთ შედეგს
        <code>
          &lt;form method="post" accept-charset="utf-8" action="http://example.com/index.php/email/send" class="email" id="myform">
        </code>

        <h3>დამალული ველები</h3>

        დამალული ველების დასამატებლად, form_open() ფუნქციას მესამე პარამეტრად უნდა გადავცეთ ასოციაციური მასივი
        <code>
          $hidden = array('username' => 'Joe', 'member_id' => '234'); <br />
          echo form_open('email/send', '', $hidden);
        </code>
        შედეგი იქნება
        <code>
          <pre>
&lt;form method="post" accept-charset="utf-8" action="http://example.com/index.php/email/send">
    &lt;input type="hidden" name="username" value="Joe" />
    &lt;input type="hidden" name="member_id" value="234" />
          </pre>
        </code>


        <h3>form_open_multipart()</h3>

        ეს ფუნქცია არის form_open_() ფუნქციის იდენტური, იმ განსხვავებით რომ ფორმას ამატებს <b>multipart</b> ატრიბუტს, რომელიც აუცილებელია
        ფაილების ასატვირთი ფორმის შესაქმნელად.


        <h3>form_input()</h3>

        საშუალებას გვაძლევს შევქმნათ ჩვეულებრივი ტექსტური ტიპის შესაყვანი ველი. სინტაქსი ასეთია
        <code>
          form_input([$data = ''[, $value = ''[, $extra = '']]])
        </code>
        $data პარამეტრი განსაზღვრავს ატრიბუტების მასივს, $value პარამეტრი განსაზღვრავს ველის "value" მნიშვნელობას,  $extra ატრიბუტი განსაზღვრავს
        ექსტრა-ატრიბუტების მასივს. შევქმნათ ტექსტის შესაყვანი სტანდარტული ველი, მას  გადავცეთ "name" და "value" ატრიბუტები
        <code>
          echo form_input('username', 'johndoe');
        </code>
        ან შესაძლებელია ატრიბუტების ასოიციაციურ მასივში თავმოყრა და ამ მასივის form_input() ფუნქციის პარამეტრად მითითება
        <code>
          <pre>
$data = array(
        'name'          => 'username',
        'id'            => 'username',
        'value'         => 'johndoe',
        'maxlength'     => '100',
        'size'          => '50',
        'style'         => 'width:50%'
);

echo form_input($data);

/*
შედეგი:

&lt;input type="text" name="username" value="johndoe" id="username" maxlength="100" size="50" style="width:50%"  />
*/
          </pre>
        </code>
        თუ გვსურს, რომ ფორმა შეიცავდეს დამატებით ინფორმაციას,  მაგალითად Javascript-ს, ეს ინფორმაცია შეგვიძლია გადავცეთ სტრიქონის სახით მესამე
        პარამეტრად
        <code>
          $js = 'onClick="some_function()"'; <br />
          echo form_input('username', 'johndoe', $js);
        </code>
        ან
        <code>
          $js = array('onClick' => 'some_function();'); <br />
          echo form_input('username', 'johndoe', $js);
        </code>


        <h3>form_password()</h3>

        ფუნქცია არის form_input() ფუნქციის ანალოგიური, უბრალოდ ქმნის “password” ტიპის ველებს.

        <h3>form_upload()</h3>

        ფუნქცია არის form_input() ფუნქციის ანალოგიური, უბრალოდ ქმნის “file” ტიპის ველებს.


        <h3>form_textarea()</h3>

        ფუნქცია არის form_input() ფუნქციის ანალოგიური, უბრალოდ ქმნის “textarea” ელემენტს,  მივაქციოთ ყურადღება იმას რომ, ზედა მაგალითში
        მოყვანილი "maxlength" და "size" ატრიბუტების ნაცვლად უნდა მივუთითოთ, "rows" და "cols".


        <h3>form_dropdown()</h3>

        ფუნქცია გამოიყენება HTML &lt;select> ელემენტის შესაქმნელად, სინტაქსი ასეთია
        <code>
          form_dropdown([$name = ''[, $options = array()[, $selected = array()[, $extra = '']]]])
        </code>
        პირველი განსაზღვრავს ელემენტის სახელს, მეორე პარამეტრი არის მასივი, რომელშიც შეტანილია  &lt;option> ელემენტების დასახელებები და
        მნიშვნელობები,  მესამე პარამეტრი კი განსაზღვრავს თუ რომელი  &lt;option> ელემენტის ამორჩევა უნდა მოხდეს ავტომატურად
        <code>
          <pre>
$options = array(
        'small'         => 'Small Shirt',
        'med'           => 'Medium Shirt',
        'large'         => 'Large Shirt',
        'xlarge'        => 'Extra Large Shirt',
);

$shirts_on_sale = array('small', 'large');
echo form_dropdown('shirts', $options, 'large');

/*
        შედეგი :

        &lt;select name="shirts">
                &lt;option value="small">Small Shirt&lt;/option>
                &lt;option value="med">Medium  Shirt&lt;/option>
                &lt;option value="large" selected="selected">Large Shirt&lt;/option>
                &lt;option value="xlarge">Extra Large Shirt&lt;/option>
        &lt;/select>
*/
          </pre>
        </code>

        <h3>form_checkbox()</h3>

        საშუალებას გვაძლევს შევქმნათ "checkbox" ტიპის ღილაკი, სინტაქსი ასეთია
        <code>
          form_checkbox([$data = ''[, $value = ''[, $checked = FALSE[, $extra = '']]]])
        </code>
        $data პარამეტრი განსაზღვრავს ატრიბუტების მასივს, $value ატრიბუტი განსაზღვრავს ელემენტის მნიშვნელობას, $checked  ატრიბუტი არის ლოგიკური
        ტიპის და განსაზღვრავს ავტომატურად მოინიშნოს თუ არა ღილაკი, $extra ატრიბუტი განსაზღვრავს დამატებით ინფორმაციას
        <code>
          echo form_checkbox('newsletter', 'accept', TRUE); <br />
          // შედეგი :  &lt;input type="checkbox" name="newsletter" value="accept" checked="checked" />
        </code>

        <code style="overflow-x: scroll;">
          <pre>
$data = array(
        'name'          => 'newsletter',
        'id'            => 'newsletter',
        'value'         => 'accept',
        'checked'       => TRUE,
        'style'         => 'margin:10px'
);

echo form_checkbox($data);
// შედეგი: &lt;input type="checkbox" name="newsletter" id="newsletter" value="accept" checked="checked" style="margin:10px" />
          </pre>
        </code>
        თუ გვსურს, რომ ელემენტი შეიცავდეს დამატებით ინფორმაციას,  მაგალითად Javascript-ს, ეს ინფორმაცია შეგვიძლია გადავცეთ სტრიქონის
        სახით მესამე  პარამეტრად
        <code>
          $js = 'onClick="some_function()"'; <br />
          echo form_checkbox('newsletter', 'accept', TRUE, $js);
        </code>
        შესაძლებელია ამ ინფორმაციის მასივში მოქცევაც
        <code>
          $js = array('onClick' => 'some_function();'); <br />
          echo form_checkbox('newsletter', 'accept', TRUE, $js);
        </code>


        <h3>form_radio()</h3>

        ფუნქცია იდენტურია წინა ფუნქციისა, უბრალოდ ქმნის "radio" ტიპის ღილაკს.

        <h3>form_label()</h3>

        ფუნქციის საშუალებით იქმნება &lt;label> ელემენტი, სინტაქსი ასეთია
        <code>
          form_label([$label_text = ''[, $id = ''[, $attributes = array()]]])
        </code>
        $label_text პარამეტრი განსაზღვრავს ელემენტის ტექსტს, $id პარამეტრი განსაზღვრავს თუ რომელი ელემენტისათვის ვქმნით &lt;label> ელემენტს,
        $attributes პარამეტრი განსაზღვრავს HTML ატრიბუტებს.
        <code>
          echo form_label('What is your Name', 'username'); <br />
          // შედეგი :  &lt;label for="username">What is your Name&lt;/label>
        </code>
        <code>
          <pre>
$attributes = array(
        'class' => 'mycustomclass',
        'style' => 'color: #000;'
);

echo form_label('What is your Name', 'username', $attributes);
// შედეგი :  &lt;abel for="username" class="mycustomclass" style="color: #000;">What is your Name&lt;/label>
          </pre>
        </code>

        <h3>form_submit()</h3>

        ფუნქციის საშუალებით იქმნება სტანდარტული "submit"  ტიპის ღილაკი, სინტაქსი ასეთია
        <code>
          form_submit([$data = ''[, $value = ''[, $extra = '']]])
        </code>
        $data პარამეტრი განსაზღვრავს ღილაკის სახელს, $value პარამეტრი მის ტექსტს, $extra პარამეტრი დამატებით ინფორმაციას.
        <code>
          echo form_submit('mysubmit', 'Submit Post!'); <br />
          // შედეგი :  &lt;input type="submit" name="mysubmit" value="Submit Post!" />
        </code>
        დამატებითი ინფორმაციის, მაგალითად JavaScript-ის მიბმის მაგალითები უკვე ვნახეთ.


        <h3>form_reset()</h3>

        ფუნქციის საშუალებით იქმნება სტანდარტული "reset"  ტიპის ღილაკი, ფუნქცია არის წინა ფუნქციის მსგავსი.


        <h3>form_button()</h3>

        ფუნქციის საშუალებით იქმნება სტანდარტული "submit"  ტიპის ღილაკი, სინტაქსი ასეთია
        <code>
          form_button([$data = ''[, $content = ''[, $extra = '']]])
        </code>
        $data პარამეტრი განსაზღვრავს ღილაკის სახელს, $value პარამეტრი მის ტექსტს, $extra პარამეტრი დამატებით ინფორმაციას.
        <code>
          echo form_button('name','content'); <br />
          // შედეგი : &lt;button name="name" type="button">Content&lt;/button>
        </code>
        <code>
          <pre>
$data = array(
        'name'          => 'button',
        'id'            => 'button',
        'value'         => 'true',
        'type'          => 'reset',
        'content'       => 'Reset'
);

echo form_button($data);
// შედეგი : &lt;button name="button" id="button" value="true" type="reset">Reset&lt;/button>
          </pre>
        </code>
        დამატებითი ინფორმაციის, მაგალითად JavaScript-ის მიბმის მაგალითები უკვე ვნახეთ.


        <h3>form_close()</h3>

        ფუნქცია ქმნის ფორმის დამხურავ ტეგს.
        <code>
          form_close([$extra = ''])
        </code>
        $extra პარამეტრად შეგვიძლია მივუთითოთ იმ ელემენტების კოდი, რომელიც გვინდა რომ ფორმის შემდეგ შეიქმნას.
        <code>
          $string = '&lt;/div>&lt;/div>';
          echo form_close($string);
          // შედეგი :  &lt;/form> &lt;/div>&lt;/div>
        </code>

      </dd>

      <dt>5. CI - HTML დამხმარე</dt>
      <dd class='answer'>

        დამხმარეს ჩატვირთვა ხდება შემდეგნაირად
        <code>
          $this->load->helper('html');
        </code>

        <h3>heading()</h3>

        ფუნქციის საშუალებით იქმნება h1-h6 HTML სათაურები, სინტაქსი შემდეგნაირია
        <code>
          heading([$data = ''[, $h = '1'[, $attributes = '']]])
        </code>
        $data პარამეტრი განსაზღვრავს სათაურის ტექსტს, $h პარამეტრი განსაზღვრავს თუ რა ზომის უნდა იყოს სათაური (1-6), $attributes განსაზღვრავს
        HTML ატრიბუტებს.
        <code>
          echo heading('Welcome!', 3, 'class="pink"'); <br />
          echo heading('How are you?', 4, array('id' => 'question', 'class' => 'green'));
        </code>
        შედეგი
        <code>
          &lt;h3 class="pink">Welcome!&lt;h3> <br />
          &lt;h4 id="question" class="green">How are you?&lt;/h4>
        </code>

        <h3>img()</h3>

        ფუნქცია ქმნის HTML &lt;img />  ტეგს, სინტაქსი ასეთია
        <code>
          img([$src = ''[, $index_page = FALSE[, $attributes = '']]])
        </code>
        $src ატრიბუტი განსაზღვრავს სურათის წყაროს, $attributes ატრიბუტი განსაზღვრავს HTML ატრიბუტებს
        <code>
          echo img('images/picture.jpg'); // შედეგი : &lt;img src="http://site.com/images/picture.jpg" />
        </code>
        <code>
          <pre style="overflow-x: scroll;">
$image_properties = array(
        'src'   => 'images/picture.jpg',
        'alt'   => 'alt text',
        'class' => 'post_images',
        'width' => '200',
        'height'=> '200',
        'title' => 'title text',
        'rel'   => 'lightbox'
);

img($image_properties);
// შედეგი :&lt;img src="http://site.com/index.php/images/picture.jpg" alt="alt text" class="post_images" width="200" height="200" title="title text" rel="lightbox" />
          </pre>
        </code>

        <h3>ul()</h3>

        ქმნის HTML &lt;ul> ელემენტს, სინტაქსი ასეთია
        <code>
          ul($list[, $attributes = ''])
        </code>
        <code>
          <pre>
$list = array(
        'red',
        'blue',
        'green',
        'yellow'
);

$attributes = array(
        'class' => 'boldlist',
        'id'    => 'mylist'
);

echo ul($list, $attributes);
          </pre>
        </code>
        შედეგი იქნება
        <code>
&lt;ul class="boldlist" id="mylist">
        &lt;li>red&lt;/li>
        &lt;li>blue&lt;/li>
        &lt;li>green&lt;/li>
        &lt;li>yellow&lt;/li>
&lt;/ul>
        </code>
        ანალოგიურად მუშაობს <b>ol()</b> ფუნქციაც.


        <h3>meta()</h3>

        ფუნქცია გვეხმარება მეტა-ტეგების ფორმირებაში, სინტაქსი ასეთია
        <code>
          meta([$name = ''[, $content = ''[, $type = 'name'[, $newline = "n"]]]])
        </code>
        <code>
          <pre>
            echo meta('description', 'My Great site');
// შედეგი :  &lt;meta name="description" content="My Great Site" />

echo meta('Content-type', 'text/html; charset=utf-8', 'equiv');
// Note the third parameter.  Can be "equiv" or "name"
// შედეგი :  &lt;meta http-equiv="Content-type" content="text/html; charset=utf-8" />

echo meta(array('name' => 'robots', 'content' => 'no-cache'));
// შედეგი :  &lt;meta name="robots" content="no-cache" />

$meta = array(
        array(
                'name' => 'robots',
                'content' => 'no-cache'
        ),
        array(
                'name' => 'description',
                'content' => 'My Great Site'
        ),
        array(
                'name' => 'keywords',
                'content' => 'love, passion, intrigue, deception'
        ),
        array(
                'name' => 'robots',
                'content' => 'no-cache'
        ),
        array(
                'name' => 'Content-type',
                'content' => 'text/html; charset=utf-8', 'type' => 'equiv'
        )
);

echo meta($meta);
// შედეგი :
// &lt;meta name="robots" content="no-cache" />
// &lt;meta name="description" content="My Great Site" />
// &lt;meta name="keywords" content="love, passion, intrigue, deception" />
// &lt;meta name="robots" content="no-cache" />
// &lt;meta http-equiv="Content-type" content="text/html; charset=utf-8" />
          </pre>
        </code>


        <h3>br()</h3>

        ფუნქცია გვეხმარება HTML &lt;br /> ტეგის შექმნაში, სინტაქსი ასეთია
        <code>
          br([$count = 1])
        </code>
        $count პარამეტრი განსაზღვრავს თუ რამდენი ცალი &lt;br /> ელემენტი უნდა შეიქმნას
        <code>
          echo br(3); // &lt;br />&lt;br />&lt;br />
        </code>
        ანალოგიურად მუშაობს <b>nbs()</b> ფუნქციაც.

      </dd>

      <dt>6. CI - URL დამხმარე</dt>
      <dd class='answer'>

        დამხმარეს ჩატვირთვა ხდება შემდეგნაირად
        <code>
          $this->load->helper('url');
        </code>

        <h3>anchor()</h3>

        ფუნქცია ქმნის სტანდარტულ HTML ბმულს საიტიას URL მისამართზე დაყრდნობით, სინტაქსი ასეთია
        <code>
          anchor($uri = '', $title = '', $attributes = '')
        </code>
        $uri პარამეტრი განსაზღვრავს ბმულის URL მისამართს, $title ატრიბუტი განსაზღვრავს ბმულის "title" ატრიბუტს, $attributes განსაზღვრავს დამატებით
        ატრიბუტებს.
        <code>
          <pre>
echo anchor('news/local/123', 'My News', 'title="News title"');
// Prints: &lt;a href="http://example.com/index.php/news/local/123" title="News title">My News&lt;/a>

echo anchor('news/local/123', 'My News', array('title' => 'The best news!'));
// Prints: &lt;a href="http://example.com/index.php/news/local/123" title="The best news!">My News&lt;/a>

echo anchor('', 'Click here');
// Prints: &lt;a href="http://example.com">Click Here&lt;/a>
          </pre>
        </code>

        <h3>site_url()</h3>

        აბრუნებს ვებ-გვერდის URL მისამართს. ფუნქციას სეგმენტები შეიძლება გადაეცეს სტრიქონის ან მასივის სახით, სტრიქონის სახით სეგმენტთა გადაცემა
        შესაძლებელია შემდეგნაირად
        <code>
          echo site_url('news/local/123'); <br />
          // დაბრუნდება დაახლოებით შემდეგნაირი URL: http://example.com/index.php/news/local/123
        </code>
        მასივის სახით სეგმენტთა გადაცემა შესაძლებელია შემდეგნაირად
        <code>
          $segments = array('news', 'local', '123'); <br />
          echo site_url($segments);
        </code>

        <h3>url_title()</h3>

        ფუნქციას არგუმენტად გადაეცემა სტრიქონი და ამ სტრიქონისაგან ქმნის ადამიანისათვის ადვილად წასაკითხ URL მისამართს. ფუნქციის გამოყენება
        ხელსაყრელია მაგალითად მაშინ თუ ჩანაწერების სათაურების URL მისამართებში გამოყენება გვსურს
        <code>
          $title = "What's wrong with CSS?";  <br />
          $url_title = url_title($title); <br />
          // შედეგი: Whats-wrong-with-CSS
        </code>
        ფუნქციას შეიძლება გადეცეს მეორე პარამეტრიც, რომელიც განსაზღვრავს სიტყვათა გამყოფს, ნაგულისმეობის პრინციპით ეს გამყოფი არის ტირე. 
        გამყოფის დასაშვები მნიშვნელობები კი არის ტირე და ქვედა ტირე, თუ ქვედა ტირის მითითება გვსურს ვიქცევით ასე
        <code>
          $title = "What's wrong with CSS?"; <br />
          $url_title = url_title($title, 'underscore'); <br />
          // შედეგი: Whats_wrong_with_CSS
        </code>
        შესაძლებელია მესამე პარამეტრის გადაცემაც, რომელიც განსაზღვრავს გამოყენებულ იქნას თუ არა დიდი ასოები URL მისამართში. ნაგულისმეობის
        პრინციპით დიდი ასოები არ გამოიყენება. ამ პარამეტრმა შეიძლება მიიღოს TRUE/FALSE მნიშვნელობები. 
        <code>
          $title = "What's wrong with CSS?"; <br />
          $url_title = url_title($title, 'underscore', TRUE); <br />
          // შედეგი: whats_wrong_with_css
        </code>

        <h3>redirect()</h3>

        ფუნქცია ახდენს მითითებულ URL მისამართზე გადამისამართებას. თუ საიტის მთლიან URL-ს მივუთითებთ გადამისამართება მაინც მოხდება მაგრამ შესაძლებელია URL-ის მხოლოდ სეგმენტების მითითებაც, ფუნქცია ამ სეგმენტებისა და სისტემის კონფიგურაციაში განსაზღვრული ძირითადი URL
        მისამართისაგან შექმნის გადასამისამართებელ ბმულს.
        <code>
          <pre>
if ($logged_in == FALSE)
{
        redirect('/login/form/');
}

// with 301 redirect
redirect('/article/13', 'location', 301);
          </pre>
        </code>

      </dd>

      <dt>7. CI - ტექსტური დამხმარე</dt>
      <dd class='answer'>

        ამ დამხმარეში აღწერილი ფუნქციები გამოიყენება ტექსტებთან სამუშაოდ, დამხმარეს ჩატვირთვა ხდება შემდეგნაირად
        <code>
          $this->load->helper('text');
        </code>

        <h3>word_limiter()</h3>

        ფუნქცია ტექსტიდან იღებს მითითებული რაოდენობის სიტყვას და აბრუნებს ამ სიტყვებისაგან შემდგარ სტრიქონს. ტექსტი და სიტყვათა რაოდენობა უნდა გადაეცეს  პარამეტრებად
        <code>
          $string = "Here is a nice text string consisting of eleven words.";  <br />
          $string = word_limiter($string, 4); <br />
          // დაბრუნდება :  Here is a nice
        </code>

        <h3>character_limiter()</h3>

        ფუნქცია ტექსტიდან იღებს მითითებული რაოდენობის სიმბოლოს და აბრუნებს ამ სიმბოლოებისაგან შემდგარ სტრიქონს. ტექსტი და სიმბოლოთა რაოდენობა უნდა გადაეცეს  პარამეტრებად, აგრეთვე უნდა აღინიშნოს, რომ ფუნქცია არ ახდენს სიტყვათა გაწყვეტას, ამიტომ შესაძლებელია
        დაბრუნებულ შედეგში იმაზე მეტი ან ნაკლები სიმბოლო შევიდეს ვიდრე ჩვენ მივუთითებთ.
        <code>
          $string = "Here is a nice text string consisting of eleven words."; <br />
          $string = character_limiter($string, 20); <br />
          // შედეგი :  Here is a nice text string
        </code>



      </dd>


   </dl>

  </div>


  <BR><BR>

  <div class="content">
      <h2 style="margin-left: 25px;">CI - ბიბლიოთეკები</h2>
  </div>

  <BR><BR>

  <div class="content">
      <dl class="faqs">


      <dt>1. CI - upload კლასი </dt>
      <dd class='answer'>

        <h2>პროცესი</h2>

        ფაილის ატვირთვის პროცესი მოიცავს შემდეგ ეტაპებს
        <ul>
          <li>ფაილის ასატვირთი ფორმის შექმნა.</li>
          <li>ფორმის გაგზავნის შემდეგ ფაილი იტვირთება მითითებულ დირექტორიაში.</li>
          <li>ატვირთვის პროცესში მოწმდება აკმაყოფილებს თუ არა ფაილი განსაზღვრულ პარამეტრებს.</li>
          <li>ატვირთვის დამთავრების შემდეგ მომხმარებელი ხედავს შესაბამის შეტყობინებას.</li>
        </ul>

        <h3>ასატვირთი ფორმის შექმნა</h3>

        <b>application/views/</b> დირექტორიაში შექვქმნათ ფაილი <b>upload_form.php</b> შემდეგი კოდით
        <code>
          <pre>
&lt;html>
&lt;head>
&lt;title>Upload Form&lt;/title>
&lt;/head>
&lt;body>

&lt;?php echo $error;?>

&lt;?php echo form_open_multipart('upload/do_upload');?>

&lt;input type="file" name="userfile" size="20" />

&lt;br />&lt;br />

&lt;input type="submit" value="upload" />

&lt;/form>

&lt;/body>
&lt;/html>
          </pre>
        </code>


        <h3>საშედეგო გვერდი</h3>

        <b>application/views/</b> დირექტორიაში შექვქმნათ ფაილი <b>upload_success.php</b> შემდეგი კოდით
        <code>
          <pre>
&lt;html>
&lt;head>
&lt;title>Upload Form&lt;/title>
&lt;/head>
&lt;body>

&lt;h3>Your file was successfully uploaded!&lt;/h3>

&lt;ul>
&lt;?php foreach ($upload_data as $item => $value):?>
&lt;li>&lt;?php echo $item;?>: &lt;?php echo $value;?>&lt;/li>
&lt;?php endforeach; ?>
&lt;/ul>

&lt;p>&lt;?php echo anchor('upload', 'Upload Another File!'); ?>&lt;/p>

&lt;/body>
&lt;/html>
          </pre>
        </code>


        <h3>კონტროლერი</h3>

        <b>application/controllers</b> დირექტორიაში შექვქმნათ ფაილი <b>Upload.php</b> შემდეგი კოდით
        <code>
          <pre>
&lt;?php

class Upload extends CI_Controller {

        public function __construct()
        {
                parent::__construct();
                $this->load->helper(array('form', 'url'));
        }

        public function index()
        {
                $this->load->view('upload_form', array('error' => ' ' ));
        }

        public function do_upload()
        {
                $config['upload_path']          = './uploads/';
                $config['allowed_types']        = 'gif|jpg|png';
                $config['max_size']             = 100;
                $config['max_width']            = 1024;
                $config['max_height']           = 768;

                $this->load->library('upload', $config);

                if ( ! $this->upload->do_upload('userfile'))
                {
                        $error = array('error' => $this->upload->display_errors());

                        $this->load->view('upload_form', $error);
                }
                else
                {
                        $data = array('upload_data' => $this->upload->data());

                        $this->load->view('upload_success', $data);
                }
        }
}
?>
          </pre>
        </code>


        <h3>ასატვირთი დირექტორია</h3>

        ახლა საჭიროა საქაღალდე სადაც შეინახება ატვირთული ფაილები. CI-ს ძირ საქაღალდეში შევქმნათ საქაღალდე <b>uploads</b>.

        <h3>ვცადოთ ! ; )</h3>

        ამისათვის უნდა შევიდეთ შემდეგ მისამართზე

        <code>
          xample.com/index.php/upload/
        </code>


      </dd>

      <dt>2. CI - form_validation კლასი</dt>
      <dd class='answer'>

        ვალიდაციის კლასის აღწერამდე ჩმოვაყალიბოთ სცენარი, რომლის მიხედვითაც მოხდება ფორმის ვალიდაცია
        <ol>
          <li>შეიქმნა ფორმა</li>
          <li>შეივსო ფორმა და გაიგზავნა</li>
          <li>
            თუ გაგზავნილ ინფორმაციაში მოხვდა რაიმე არასწორი ინფორმაცია ან არ შევავსეთ აუცილებლად შესავსები ველი, ფორმა უნდა გამოისახოს შეყვანილ
            ინფორმაციასთან ერთად და აგრეთვე გამოჩნდეს შეტყობინება მომხდარი შეცდომის შესახებ.
          </li>
          <li>ეს პროცესი გაგრძელდება მანამ სანამ არ აიკრიფება კორექტული და სწორი ინფორმაცია.</li>
        </ol>

        ამ პროცესების პარალელურად სერვერული მხარის კოდმა უნდა გააკეთოს შემდეგი რამ
        <ol>
          <li>შეამოწმოს შეივსო თუ არა აუცილებელი ველები.</li>
          <li>
            შეამოწმოს სწორი ტიპისაა თუ არა აკრეფილი ინფორმაცია, მაგალითად აიკრიფა თუ არა კორექტული ელ_ფოსტა, ან ტელეფონის ნომერი შედგება
            თუ არა მხოლოდ ციფრებისაგან და ა.შ
          </li>
          <li>
            აკრეფილი ინფორმაცია გაიწმინდოს არასასურველი სიმბოლოებისაგან
          </li>
          <li>მოხდეს ინფორმაციის დაფორმატება თუ ეს საჭიროა (მაგალითად თუ აკრეფილ ტექსტში შესულია HTML ელემენტები)</li>
          <li>გამზადდეს ინფორმაცია მბ-ში შესატანად</li>
        </ol>

        ფორმის ვალიდაციისათვის გვჭირდება სამი რამ
        <ol>
          <li>წარმოდგენის ფაილი სადაც შეიქმნება თავად ფორმა.</li>
          <li>წარმოდგენის ფაილი შედეგის გამოსატანად.</li>
          <li>კონტროლერის ფაილი რომელიც დაამუშავებს ინფორმაციას.</li>
        </ol>

        <h3>ფორმა</h3>

        <b>application/views/</b> საქაღალდეში შევქმნათ ფაილი <b>myform.php</b> შემდეგი კოდით
        <code>
          <pre>
&lt;html>
&lt;head>
&lt;title>My Form&lt;/title>
&lt;/head>
&lt;body>

&lt;?php echo validation_errors(); ?>

&lt;?php echo form_open('form'); ?>

&lt;h5>Username&lt;/h5>
&lt;input type="text" name="username" value="" size="50" />

&lt;h5>Password&lt;/h5>
&lt;input type="text" name="password" value="" size="50" />

&lt;h5>Password Confirm&lt;/h5>
&lt;input type="text" name="passconf" value="" size="50" />

&lt;h5>Email Address&lt;/h5>
&lt;input type="text" name="email" value="" size="50" />

&lt;div>&lt;input type="submit" value="Submit" />&lt;/div>

&lt;/form>

&lt;/body>
&lt;/html>
          </pre>
        </code>

        <h3>საშედეგო გვერდი</h3>

        <b>application/views/</b> საქაღალდეში შევქმნათ ფაილი <b>formsuccess.php</b> შემდეგი კოდით
        <code>
          <pre>
&lt;html>
&lt;head>
&lt;title>My Form&lt;/title>
&lt;/head>
&lt;body>

&lt;h3>Your form was successfully submitted!&lt;/h3>

&lt;p>&lt;?php echo anchor('form', 'Try it again!'); ?>&lt;/p>

&lt;/body>
&lt;/html>
          </pre>
        </code>

        <h3>კონტროლერი</h3>

        <b>application/controllers/</b> საქაღალდეში შევქმნათ ფაილი <b>Form.php</b> შემდეგი კოდით
        <code>
          <pre>
&lt;?php

class Form extends CI_Controller {

        public function index()
        {
                $this->load->helper(array('form', 'url'));

                $this->load->library('form_validation');

                if ($this->form_validation->run() == FALSE)
                {
                        $this->load->view('myform');
                }
                else
                {
                        $this->load->view('formsuccess');
                }
        }
}
          </pre>
        </code>

        <h3>ვცადოთ ! ; )</h3>

        ამისათვის უნდა შევიდეთ შემდეგ მისამართზე

        <code>
          example.com/index.php/form/
        </code>
        მაგრამ ვალიდაცია ჯერ არ დასრულებულა, თუ ახლა ფორმას გავაგზავნით გვერდი უბრალოდ დარეფრეშდება, რადგანაც ჯერ არ მიგვითითებია ვალიდაციის
        წესები, წესების განსაზღვრის გარეშე კი  ვალიდაციის კლასი ყოველთვის დაავრუნებს FALSE მნიშვნელობას,  run() მეთოდი TRUE მნიშვნელობას აბრუნებს
        მხოლოდ მაშინ, თუ ვალიდაციის კანონების გათვალისწინების შემდეგ არ დაფიქსირდება არანაირი შეცდომა.

        <p>
          გავაკეთოთ რამოდენიმე შენიშვნა ზემოთ აღწერილი ფაილების შესახებ, myform.php ფაილში აღწერილი ფორმა არის ჩვეულებრივი ვებ-ფორმა რამოდენიმე
          თავისებურებით
        </p>
        <ol>
          <li>
            იგი იყენებს ფორმის დამხმარე კლასს, ფორმის გამხსნელი ტეგის შესაქმნელად, ტექნიკური თვალსაზრისით ეს აუცილებელი არ არის, ამ ტეგის გახსნა
            HTML-ის დახმარებითაც შეიძლება, თუმცა დამხმარეს გამოყენების უპირატესობა იმაშია, რომ იგი ახდენს ფორმის "action" ატრიბუტისათვის გადასაცემ
            URL მისამართს, კონფიგურაციულ ფაილში მითითებულიURL-ზე დაყრდნობით. ეს კი აპლიკაციას უფრო მოქნილს ხდის იმ შემთხვევისათვის თუ  შეიცვლება
            აპლიკაციის URL მისამართები.

          </li>
          <li>
            ამავე ფაილში შევამჩნევთ შემდეგი ფუნქციის გამოძახებას
            <code>
              &lt;?php echo validation_errors(); ?>
            </code>
            ეს ფუნქცია დააბრუნებს შეტყობინებას ვალიდაციისას დაფიქსირებული შეცდომის შესახებ, ხოლო თუ შეცდომა არ მოხდება მაშინ დააბრუნებს ცარიელ
            სტრიქონს.

          </li>
        </ol>
        Form.php კონტროლერს აქვს ერთი მეთოდი index(), ეს მეთოდი ახდენს ვალიდაციის კლასის ინიციალიზაციას და ტვირთავს ფორმისა და URL-ების დამხმარე
        კლასებს, აგრეთვე მისი მეშვეობით ხდება ვალიდაციის პროცესის გაშვება, იმისდამიხედვით წარმატებით დასრულდება თუ არა ვალიდაცია მეთოდი ჩატვირთავს
        ან ისევ ფორმას, ან შედეგის გვერდს.

        <h3>ვალიდაციის კანონების განსაზღვრა</h3>

        CI საშუალებას გვაძლევს განვსაზღვროთ ვალიდაციის იმდენი წესი რამდენიც საჭიროა ველების რაოდენობიდან გამომდინარე, ვალიდაციის წესების მისათითებლად
        უნდა გამოვიყენოთ <b>set_rules()</b> მეთოდი.

        <code>
          $this->form_validation->set_rules();
        </code>
        ამ მეთოდ უნდა გადაეცეს სამი პარამეტრი
        <ol>
          <li>ველის სახელი</li>
          <li>
            ადამიანისათვის გასაგები ველის სახელი რომელსაც კოდი გამოიყენებს შედეგების წარმოდგენისას, მაგალითად თუ ველს ჰქვია "user", ადამიანისათვის
            გასაგებ სახელად შეიძლება მივუთითოთ  “Username”.
          </li>
          <li>ვალიდაციის წესი</li>
          <li>(ნებაყოფლობითი) გადაეცეს ველის ვალიდაციის წესის შესაბამისი შეტყობინება შეცდომის დაფიქსირებისას.</li>
        </ol>
        <code>
          $this->form_validation->set_rules('username', 'Username', 'required'); <br />
          $this->form_validation->set_rules('password', 'Password', 'required'); <br />
          $this->form_validation->set_rules('passconf', 'Password Confirmation', 'required'); <br />
          $this->form_validation->set_rules('email', 'Email', 'required'); <br />
        </code>
        ჩავამატოთ ეს კოდი კონტროლერში, ვალიდაციის ინიციალიზაციის შემდეგ
        <code>
          <pre>
&lt;?php

class Form extends CI_Controller {

        public function index()
        {
                $this->load->helper(array('form', 'url'));

                $this->load->library('form_validation');

                $this->form_validation->set_rules('username', 'Username', 'required');
                $this->form_validation->set_rules('password', 'Password', 'required',
                        array('required' => 'You must provide a %s.')
                );
                $this->form_validation->set_rules('passconf', 'Password Confirmation', 'required');
                $this->form_validation->set_rules('email', 'Email', 'required');

                if ($this->form_validation->run() == FALSE)
                {
                        $this->load->view('myform');
                }
                else
                {
                        $this->load->view('formsuccess');
                }
        }
}
          </pre>
        </code>
        თუ ახლა გავაგზავნით ფორმას უკვე შედეგსაც ვიხილავთ, ცარიელი ველების გაგზავნისას ვიხილავთ შესაბამისი შეცდომების შეტყობინებას, ხოლო თუ ველებს
        შევავსებთ - წარმატების გვერდს. <b>თუმცა ერთი ხარვეზი კიდევ ფიქსირდება: შეცდომის დაფიქსირებისას ფორმა აღარ ივსება ავტომატურად, ანუ თუ შევიყბანეთ
        სამი ველის მნიშვნელობა და არ შევიყვანეთ მეოთხესი, შეცდომის შეტყობინება კი გამოდის მაგრამ სწორად შეყვანილი ინფორმაციაც იკარგება. ამ პრობლემას
        ქვემოთ მოვაგვარებთ.</b>

        <h3>ვალიდაციის კანონების განსაზღვრა მასივის მეშვეობით</h3>

        <code>
          <pre>
$config = array(
        array(
                'field' => 'username',
                'label' => 'Username',
                'rules' => 'required'
        ),
        array(
                'field' => 'password',
                'label' => 'Password',
                'rules' => 'required',
                'errors' => array(
                        'required' => 'You must provide a %s.',
                ),
        ),
        array(
                'field' => 'passconf',
                'label' => 'Password Confirmation',
                'rules' => 'required'
        ),
        array(
                'field' => 'email',
                'label' => 'Email',
                'rules' => 'required'
        )
);

$this->form_validation->set_rules($config);
          </pre>
        </code>


        <h3>შეცდომის შეტყობინების განსაზღვრა</h3>

        როგორც ვიცით ვალიდაციის რომელიმე წესის დარღვევის შემდეგ ფიქსირდება შეცდომა და გამოდის შესაბამისი შეტყობინება, ეს შეტყობინებები განსაზღვრულია შემდეგ ფაილში - <b>system/language/english/form_validation_lang.php</b>.
        <p>
          საკუთარი შეტყობინებების განსასაზღვრავად არსებობს ორი გზა: ან ამ ფაილში მითითებული შეტყობინება უნდა გადავაკეთოთ ანდა განვსაზღვროთ ახალი შეტყობინება
        </p>
        <code>
          $this->form_validation->set_message('rule', 'Error Message');
        </code>
        თუ გვსურს, რომ შეტყობინებაში ჩაერთოს ველის, ადამიანისათვის გასაგები  დასახელება, ან რომელიმე პარამეტრის მნიშვნელობა (მაგ: max_length), მაშინ შეტყობინებაში უნდა ჩავამატოთ  {field} და {param} ტეგები. 
        <code>
          $this->form_validation->set_message('min_length', '{field} უნდა შეიცავდეს მინიმუმ {param} სიმბოლოს.');
        </code>
        ასეთ შემთხვევაში თუ ველის, ადამიანისათვის გასაგები  დასახელეაა "Username" და მას აქვს შეზღუდვა, რომ უნდა შეიცავდეს მინიმუმ 5 სიმბოლოს, შეცდომის დაფიქსირების შემთხვევაში გამოვა შემდეგი შეტყობინება
        <code>
          “Username შეიცავდეს მინიმუმ 5 სიმბოლოს.”
        </code>





        <h3>ვალიდაციის კასკადური კანონები</h3>

        CI საშუალებას გვაძლევს ერთი ველისათვის განვსაზღვროთ ვალიდაციის რამოდენიმე წესი
        <code>
          <pre>
$this->form_validation->set_rules(
        'username', 'Username',
        'required|min_length[5]|max_length[12]|is_unique[users.username]',
         array(
                'required'      => 'You have not provided %s.',
                'is_unique'     => 'This %s already exists.'
        )
);
$this->form_validation->set_rules('password', 'Password', 'required');
$this->form_validation->set_rules('passconf', 'Password Confirmation', 'required|matches[password]');
$this->form_validation->set_rules('email', 'Email', 'required|valid_email|is_unique[users.email]');
          </pre>
        </code>
        ეს კოდი განსაზღვრავს შემდეგ კანონებს
        <ol>
          <li>"username" ველი უნდა შეიცავდეს 5 სიმბოლოზე მეტს და 12 სიმბოლოზე ნაკლებს</li>
          <li>"password" ველის მნიშვნელობა უნდა დაემთხვეს "password confirmation" ველის მნიშვნელობას </li>
          <li>"email" ველი უნდა შეიცავდეს კორექტულ ელ_ფოსტას</li>
        </ol>

        <h3>მონაცემთა მომზადება</h3>

        <code>
          $this->form_validation->set_rules('username', 'Username', 'trim|required|min_length[5]|max_length[12]'); <br />
          $this->form_validation->set_rules('password', 'Password', 'trim|required|min_length[8]'); <br />
          $this->form_validation->set_rules('passconf', 'Password Confirmation', 'trim|required|matches[password]'); <br />
          $this->form_validation->set_rules('email', 'Email', 'trim|required|valid_email');
        </code>

        მოყვანილ მაგალითში ხდება მონაცემთა "გადამზადება", მოწმდება სიგრძეები სადაც ეს საჭიროა და აგრეთვე მოწმდება  ემთხვევა თუ არა პაროლები.
        <b>ნებისმიერი PHP-ის ფუნქცია, რომელსაც გადაეცემა ერთი პარამეტრი, შესაძლებელია გამოყენებულ იქნას როგორც ვალიდაციის წესი. მაგალითად
        "htmlspecialchars()", "trim()" და ა.შ</b>

        <h3>ველთა განმეორებითი, ავტომატური შევსება</h3>

        ველთა განმეორებითი, ავტომატურად შესავსებად გამოიყენება <b>set_value('field name')</b> ფუნქცია. გავხსნათ myform.php წარმოდგენის ფაილი
        <code>
          <pre>
&lt;html>
&lt;head>
&lt;title>My Form&lt;/title>
&lt;/head>
&lt;body>

&lt;?php echo validation_errors(); ?>

&lt;?php echo form_open('form'); ?>

&lt;h5>Username&lt;/h5>
&lt;input type="text" name="username" value="&lt;?php echo set_value('username'); ?>" size="50" />

&lt;h5>Password&lt;/h5>
&lt;input type="text" name="password" value="&lt;?php echo set_value('password'); ?>" size="50" />

&lt;h5>Password Confirm&lt;/h5>
&lt;input type="text" name="passconf" value="&lt;?php echo set_value('passconf'); ?>" size="50" />

&lt;h5>Email Address&lt;/h5>
&lt;input type="text" name="email" value="&lt;?php echo set_value('email'); ?>" size="50" />

&lt;div>&lt;input type="submit" value="Submit" />&lt;/div>

&lt;/form>

&lt;/body>
&lt;/html>
          </pre>
        </code>
        თუ ფორმის ველების დასახელებები მოქცეული გვაქვს მასივში, მაშინ set_value() ფუნქცია უნდა გამოვიყენოთ ასე
        <code>
          &lt;input type="text" name="colors[]" value="<?php echo set_value('colors[]'); ?>" size="50" />
        </code>

        <h3>ვალიდაციის საკუთარი კანონები, საპასუხო ფუნქციები</h3>

        CI საშუალებას გვაძლევს ვალიდაციის კლასი მოვარგოთ ჩვენს საჭიროებებს, მაგალითად გვაინტერესებს რეგისტრაციისას მომხმარებლის მიერ შეყვანილი სახელი უკვე გამოყენებული ხომ არ აქვს ვინმეს, ამის შემოწმება უნდა მოხდეს შესაბამის საპასუხო ფუნქციაში (callback). კონტროლერში სახელის
        ვალიდაციის წესი იქნება შემდეგნაირი
        <code>
          $this->form_validation->set_rules('username', 'Username', 'callback_username_check');
        </code>
        ახლა კი უნდა აღვწეროთ <b>username_check()</b> ფუნქცია, რომელიც მოახდენს სახელის უნიკალურობის გადამოწმებას
        <code style="overflow-x: scroll; ">
          <pre>
&lt;?php

class Form extends CI_Controller {

        public function index()
        {
                $this->load->helper(array('form', 'url'));

                $this->load->library('form_validation');

                $this->form_validation->set_rules('username', 'Username', 'callback_username_check');
                $this->form_validation->set_rules('password', 'Password', 'required');
                $this->form_validation->set_rules('passconf', 'Password Confirmation', 'required');
                $this->form_validation->set_rules('email', 'Email', 'required|is_unique[users.email]');

                if ($this->form_validation->run() == FALSE)
                {
                        $this->load->view('myform');
                }
                else
                {
                        $this->load->view('formsuccess');
                }
        }

        public function username_check($str)
        {
                if ($str == 'test')
                {
                        $this->form_validation->set_message('username_check', 'The {field} field can not be the word "test"');
                        return FALSE;
                }
                else
                {
                        return TRUE;
                }
        }

}            
          </pre>
        </code>
        ამის შემდეგ თუ ფორმას დავარესტარტებთ და მომხმარებლის სახელად შევივანთ სიტყვას - “test”, ვიხილავთ username_check() ფუნქციის
        მუშაობის შედეგს.
        <p>
          <b>ვალიდაციის კანონში ფუნქციის მითითება უნდა მოხდეს “callback_” წინსართთან ერთად.</b>
        </p>

        <h2>ვალიდაციისას წესები, კრიტერიუმები</h2>

        <table>
          <colgroup>
          <col width="16%" />
          <col width="7%" />
          <col width="61%" />
          <col width="16%" />
          </colgroup>
          <thead valign="bottom">
          <tr class="row-odd"><th class="head">წესი</th>
          <th class="head">პარამეტრი</th>
          <th class="head">აღწერა</th>
          <th class="head">მაგალითი</th>
          </tr>
          </thead>
          <tbody valign="top">
          <tr class="row-even"><td><strong>required</strong></td>
          <td>არა</td>
          <td>აბრუნებს FALSE-ს თუ ფორმის ელემენტი ცარიელია.</td>
          <td>&nbsp;</td>
          </tr>
          <tr class="row-odd"><td><strong>matches</strong></td>
          <td>დიახ</td>
          <td>აბრუნებს FALSE-ს თუ ფორმის ელემენტის მნიშვნელობა არ ემთხვევა პარამეტრად გადაცემულ მნიშვნელობას.</td>
          <td>matches[form_item]</td>
          </tr>
          <tr class="row-even"><td><strong>regex_match</strong></td>
          <td>დიახ</td>
          <td>აბრუნებს FALSE-ს თუ ფორმის ელემენტის მნიშვნელობა არ ემთხვევა რეგულარულ გამოსახულებას.</td>
          <td>regex_match[/regex/]</td>
          </tr>
          <tr class="row-odd"><td><strong>differs</strong></td>
          <td>დიახ</td>
          <td>აბრუნებს FALSE-ს თუ ფორმის ელემენტის მნიშვნელობა არ განსხვავდება პარამეტრად გადაცემული მნიშვნელობისაგან.</td>
          <td>differs[form_item]</td>
          </tr>
          <tr class="row-even"><td><strong>is_unique</strong></td>
          <td>დიახ</td>
          <td>აბრუნებს FALSE-ს თუ ფორმის ელემენტის მნიშვნელობა არ არის უნიკალური პარამეტყრად მითითებული ცხრილის ველის მნიშვნელობებს შორის.
          შენიშვნა: ამ წესის გამოსაყენებლად აუცილებელია ვიყენებდეთ Query Builder-ს.
          </td>
          <td>is_unique[table.field]</td>
          </tr>
          <tr class="row-odd"><td><strong>min_length</strong></td>
          <td>დიახ</td>
          <td>აბრუნებს FALSE-ს ფორმის ელემენტის მნიშვნელობის სიგრძე ნაკლებია მითითებულ პარამეტრზე.</td>
          <td>min_length[3]</td>
          </tr>
          <tr class="row-even"><td><strong>max_length</strong></td>
          <td>დიახ</td>
          <td>აბრუნებს FALSE-ს ფორმის ელემენტის მნიშვნელობის სიგრძე მეტია მითითებულ პარამეტრზე.</td>
          <td>max_length[12]</td>
          </tr>
          <tr class="row-odd"><td><strong>exact_length</strong></td>
          <td>დიახ</td>
          <td>აბრუნებს FALSE-ს თუ ფორმის ელემენტის მნიშვნელობის სიგრძე არ ემთხვევა მითითებულ პარამეტრს.</td>
          <td>exact_length[8]</td>
          </tr>
          <tr class="row-even"><td><strong>greater_than</strong></td>
          <td>დიახ</td>
          <td>აბრუნებს FALSE-ს თუ ფორმის ელემენტის მნიშვნელობა ნაკლებია ან ტოლი პარამეტრზე, ან საერთოდ არ არის რიცხვითი ტიპის.
          </td>
          <td>greater_than[8]</td>
          </tr>
          <tr class="row-odd"><td><strong>greater_than_equal_to</strong></td>
          <td>დიახ</td>
          <td>აბრუნებს FALSE-ს თუ ფორმის ელემენტის მნიშვნელობა ნაკლებია პარამეტრზე, ან საერთოდ არ არის რიცხვითი ტიპის.
          </td>
          <td>greater_than_equal_to[8]</td>
          </tr>
          <tr class="row-even"><td><strong>less_than</strong></td>
          <td>დიახ</td>
          <td>აბრუნებს FALSE-ს თუ ფორმის ელემენტის მნიშვნელობა მეტია ან ტოლი პარამეტრზე, ან საერთოდ არ არის რიცხვითი ტიპის.</td>
          <td>less_than[8]</td>
          </tr>
          <tr class="row-odd"><td><strong>less_than_equal_to</strong></td>
          <td>დიახ</td>
          <td>აბრუნებს FALSE-ს თუ ფორმის ელემენტის მნიშვნელობა მეტია პარამეტრზე, ან საერთოდ არ არის რიცხვითი ტიპის.</td>
          <td>less_than_equal_to[8]</td>
          </tr>
          <tr class="row-even"><td><strong>in_list</strong></td>
          <td>დიახ</td>
          <td>აბრუნებს FALSE-ს თუ ფორმის ელემენტის მნიშვნელობა არ არის წინასწარ განსაზღვრულ სიაში.</td>
          <td>in_list[red,blue,green]</td>
          </tr>
          <tr class="row-odd"><td><strong>alpha</strong></td>
          <td>არა</td>
          <td>აბრუნებს FALSE-ს თუ ფორმის ელემენტის მნიშვნელობა შეიცავს რაიმეს გარდა ასოებისა.</td>
          <td>&nbsp;</td>
          </tr>
          <tr class="row-even"><td><strong>alpha_numeric</strong></td>
          <td>არა</td>
          <td>აბრუნებს FALSE-ს თუ ფორმის ელემენტის მნიშვნელობა შეიცავს რაიმეს გარდა ასოებისა და ციფრებისა.</td>
          <td>&nbsp;</td>
          </tr>
          <tr class="row-odd"><td><strong>alpha_numeric_spaces</strong></td>
          <td>არა</td>
          <td>აბრუნებს FALSE-ს თუ ფორმის ელემენტის მნიშვნელობა შეიცავს რაიმეს გარდა ასოებისა, ციფრებისა და გამოტოვებული ადგილებისა.</td>
          <td>&nbsp;</td>
          </tr>
          <tr class="row-even"><td><strong>alpha_dash</strong></td>
          <td>არა</td>
          <td>აბრუნებს FALSE-ს თუ ფორმის ელემენტის მნიშვნელობა შეიცავს რაიმეს გარდა ასოებისა, ციფრებისა, ტირეებისა და ქვედა ტირეებისა.</td>
          <td>&nbsp;</td>
          </tr>
          <tr class="row-odd"><td><strong>numeric</strong></td>
          <td>არა</td>
          <td>აბრუნებს FALSE-ს თუ ფორმის ელემენტის მნიშვნელობა შეიცავს რაიმეს გარდა ციფრებისა.</td>
          <td>&nbsp;</td>
          </tr>
          <tr class="row-even"><td><strong>integer</strong></td>
          <td>არა</td>
          <td>აბრუნებს FALSE-ს თუ ფორმის ელემენტის მნიშვნელობა შეიცავს რაიმეს გარდა მთელი რიცხვებისა.</td>
          <td>&nbsp;</td>
          </tr>
          <tr class="row-odd"><td><strong>decimal</strong></td>
          <td>არა</td>
          <td>აბრუნებს FALSE-ს თუ ფორმის ელემენტის მნიშვნელობა შეიცავს რაიმეს გარდა ათწილადი რიცხვებისა.</td>
          <td>&nbsp;</td>
          </tr>
          <tr class="row-even"><td><strong>is_natural</strong></td>
          <td>არა</td>
          <td>აბრუნებს FALSE-ს თუ ფორმის ელემენტის მნიშვნელობა შეიცავს რაიმეს გარდა ნატურალური რიცხვებისა.</td>
          <td>&nbsp;</td>
          </tr>
          <tr class="row-odd"><td><strong>is_natural_no_zero</strong></td>
          <td>არა</td>
          <td>აბრუნებს FALSE-ს თუ ფორმის ელემენტის მნიშვნელობა შეიცავს რაიმეს გარდა ნატურალური რიცხვებისა,  არ უნდა უდრიდეს 0-ს.</td>
          <td>&nbsp;</td>
          </tr>
          <tr class="row-even"><td><strong>valid_url</strong></td>
          <td>არა</td>
          <td>აბრუნებს FALSE-ს თუ ფორმის ელემენტის მნიშვნელობა არ შეიცავს კორექტულ URL მისამართს.</td>
          <td>&nbsp;</td>
          </tr>
          <tr class="row-odd"><td><strong>valid_email</strong></td>
          <td>არა</td>
          <td>აბრუნებს FALSE-ს თუ ფორმის ელემენტის მნიშვნელობა არ შეიცავს ელ_ფოსტის კორექტულ მისამართს.</td>
          <td>&nbsp;</td>
          </tr>
          <tr class="row-even"><td><strong>valid_emails</strong></td>
          <td>არა</td>
          <td>აბრუნებს FALSE-ს თუ მძიმით გამოყოფილი მნიშვნელობებიდან ერთი მაინც არ შეიცავს ელ_ფოსტის კორექტულ მისამართს.</td>
          <td>&nbsp;</td>
          </tr>
          <tr class="row-odd"><td><strong>valid_ip</strong></td>
          <td>დიახ</td>
          <td>აბრუნებს FALSE-ს თუ მითითებული IP მისამართი არ არის კორექტული.</td>
          <td>&nbsp;</td>
          </tr>
          </tbody>
        </table>


      </dd>

      <dt>3. CI - input კლასი</dt>
      <dd class='answer'>

        ამ კლასის ინიციალიზაცია ავტომატურტად ხდება, ამიტომ ჩვენ აღარ გვჭირდება მისი ჩატვირთვა.

        <h2>ფორმის მონაცემებთან წვდომა</h2>

        <h3>POST, GET, COOKIE, SERVER მონაცემების გამოყენება</h3>

        input კლასის მეთოდების მეშვეობით შესაძლებელია დავაფიქსიროთ POST, GET, COOKIE ან SERVER გლობალურ ცვლადებში მოთავსებული მონაცემები.
        როგორც ვიცით PHP-ში მაგალითად POST ტიპის ინფორმაციის მიღება ხდება შემდეგნაირად
        <code>
          $something = isset($_POST['something']) ? $_POST['something'] : NULL;
        </code>
        CI-ში კი იგივე მოხდება შემდეგნაირად
        <code>
          $something = $this->input->post('something');
        </code>
        ანუ <b>post()</b> მეთოდი ამოწმებს არსებობს თუ არა POST გლობალურ ცვლადში ინფორმაცია,  თუ არსებობს აბრუნებს მას თუ არადა აბრუნებს NULL-ს.

        input კლასის ძირითადი მეთოდებია
        <ul class="simple">
            <li>$this-&gt;input-&gt;post()</li>
            <li>$this-&gt;input-&gt;get()</li>
            <li>$this-&gt;input-&gt;cookie()</li>
            <li>$this-&gt;input-&gt;server()</li>
        </ul>

        <h3>post()</h3>

        მეთოდის გამოყენების მაგალითი
        <code>
          $this->input->post('some_data');
        </code>
        პირველი პარამეტრი უნდა შეიცავდეს POST მასივის იმ გასაღებს რომლის მნიშვნელობასაც ვეძებთ, ბრუნდება NULL თუ ეს მნიშვნელობა განსაზღვრული არ არის.
        POST მასივში მოთავსებული ყველა მნიშვნელობის დასაბრუნებლად post() მეთოდი უნდა გამოვიძახოთ პარამეტრების გარეშე
        <code>
          $this->input->post(NULL, TRUE); //  XSS ფილტრით  <br />
          $this->input->post(NULL, FALSE); // XSS ფილტრის გარეშე
        </code>
        კონკრეტული მნიშვნელობების დასავრუნებლად მეთოდს პარამეტრებად უნდა გადავცეთ ფორმის შესაბამისი ველების დასახელებები
        <code>
          $this->input->post(array('field1', 'field2'));
        </code>

        <h3>get()</h3>

        ეს მეთოდი არის post() მეთოდის იდენტური, უბრალოდ იგი აბრუნებს GET მასივში მოთავსებულ მნიშვნელობებს.


        <h3>server()</h3>

        ეს მეთოდიც მუშაობდ post() და get() მეთოდების ანალოგიურად.
        <code>
          $this->input->server('some_data');
        </code>
        თუ რამოდენიმე მნიშვნელობის ამორება გვურს $_SERVER გლობალური მასივიდან ვიქცევით ასე
        <code>
          $this->input->server(array('SERVER_PROTOCOL', 'REQUEST_URI'));
        </code>


        <h3>ip_address()</h3>

        მეთოდი აბრუნებს ვისიტორის ip მისამართს, თუ ეს მისამართი არაკორეკტულია ბრუნდება ‘0.0.0.0’
        <code>
          echo $this->input->ip_address();
        </code>


        <h3>valid_ip()</h3>

        მეთოდი აბრუნებს TRUE აბ FALSE მნიშვნელობებს, გამომდინარე იქიდან, კორექტულია თუ არა ip
        <code>
          <pre>
if ( ! $this->input->valid_ip($ip))
{
        echo 'Not Valid';
}
else
{
        echo 'Valid';
}
          </pre>
        </code>

      </dd>

      <dt>4. CI - pagination კლასი</dt>
      <dd class='answer'>

        <h2>კონკრეტული მაგალითი</h2>

        <code>
          « პირველი &lt; 1 2 3 4 5 &gt; ბოლო »</span>
        </code>

        მოვიყვანოთ მაგალითი თუ როგორ უნდა გაკეთდეს პაგინაცია კონტროლერის მეთოდის მეშვეობით
        <code>
          $this->load->library('pagination'); <br /><br />

          $config['base_url'] = 'http://example.com/index.php/test/page/'; <br />
          $config['total_rows'] = 200; <br />
          $config['per_page'] = 20; <br /><br />

          $this->pagination->initialize($config); <br /><br />

          echo $this->pagination->create_links();
        </code>

        <h3>შენიშვნები</h3>

        <b>$config</b> მასივი შეიცავს კონფიგურაციულ ცვლადებს, ამ მასივის გადაცემა ხდება <b>$this->pagination->initialize()</b> ჩანაწერით, შესაძლებელია
        სხვა კონფიგურაციული პარამეტრების გადაცემაც მაგრამ ეს სამი არის აუცილებელი და ძირითადი
        <ol>
          <li>
            <b>base_url</b> - ეს არის პაგინაციის კონტროლერის კლასის/ფუნქციის სრული URL მისამართი, ამ მაგალითის მიხედვით ხდება “Test” კლასისა და მისი
            “page” მეთოდის გამოძახება.
          </li>
          <li>
            <b></b> - ეს რიცხვი განსაზღვრავს შედეგთა ნაკრებში ჩანაწერების რაოდენობას, როგორც წესი ეს რიცხვი ტოლია ხოლმე მბ-დან დაბრუნებული, პასუხთა
            ნაკრების სიგრძისა.
          </li>
          <li>
            <b></b> - ეს რიცხვი განსაზღვრავს თუ რამდენი ჩანაწერი უნდა გამოჩნდეს ერთ გვერდზე.
          </li>
        </ol>

        <b>create_links()</b> მეთოდი აბრუნებს ცარიელ სტრიქონს თუ პაგინაციაში მოსათავსებლად ვერაფერი მოიძებნება.

        <h2>პარამეტრების განსაზღვრა კონფიგურაციის ფაილში</h2>

        პაგინაციის კონფიგურაციული პარამეტრების განსაზღვრა შესაძლებელია ცალკე ფაილშიც, <b>application/config/</b> დირექტორიაში გავაკეთოთ ფაილი
        <b>pagination.php</b>,  მასში შევქმნათ მასივი <b>$config</b>, მისი გამოყენება მოხდება ავტომატურად, ამ შემთხვევაში $this->pagination->initialize()
        ჩანაწერის გამოყენება აღარ დაგვჭირდება.

        <h3>$config[‘uri_segment’] = 3;</h3>

        პაგინაციის ფუნქცია ავტომატურად განსაზღვრავს თუ URI მისამართის რომელი სეგმენტი შეიცავს გვერდის ნომერს.

        <h3>$config[‘num_links’] = 2;</h3>

        ეს პარამეტრი განსაზღვრავს თუ რამდენი ბმული უნდა გამოჩნდესპაგინაციაში არჩეული ბმულის წინ და შემდეგ.

        <h3>$config[‘page_query_string’] = TRUE;</h3>

        ნაგულისხმეობის პრინციპით, პაგინაციის კლასი აღიქვამს დაახლოებით შემდეგნაირ  URI  მისამართებს
        <code>
          http://example.com/index.php/test/page/20
        </code>

        თუ $config['enable_query_strings']-ს განვუსაზღვრავთ მნიშვნელობას - TRUE, მაშინ შესაძლებელი იქნება ასეთი URI  მისამართების გამოყენებაც
        <code>
          http://example.com/index.php?c=test&m=page&per_page=20
        </code>

        <h2>პაგინაციის ბლოკის HTML ელემენტში მოქცევა</h2>

        <h3>$config[‘full_tag_open’] = ‘&lt;p>’;</h3>

        <h3>$config[‘full_tag_close’] = ‘&lt;p>’;</h3>


        <h2>"პირველი" ბმულის შექმნა</h2>

        <h3>$config[‘first_link’] = ‘პირველი’;</h3>


        <h3>$config[‘first_tag_open’] = ‘&lt;div>’;</h3>

        გამხსნელი ტეგი "პირველი" ბმულისათვის.

        <h3>$config[‘first_tag_close’] = ‘&lt;div>’;</h3>

        დამხურავი ტეგი "პირველი" ბმულისათვის

        <h3>$config[‘first_url’] = ‘’;</h3>

        ალტერნატიული URL მისამართი "პირველი" ბმულისათვის.



        <h2>"ბოლო" ბმულის შექმნა</h2>

        <h3>$config[‘last_link’] = ‘ბოლო’;</h3>


        <h3>$config[‘last_tag_open’] = ‘&lt;div>’;</h3>

        გამხსნელი ტეგი "ბოლო" ბმულისათვის.

        <h3>$config[‘last_tag_close’] = ‘&lt;div>’;</h3>

        დამხურავი ტეგი "ბოლო" ბმულისათვის.


        <h2>"შემდეგი" ბმულის შექმნა</h2>

        <h3>$config[‘last_link’] = ‘შემდეგი’;</h3>
        ან
        <h3>$config[‘last_link’] = ‘&gt;’;</h3>


        <h3>$config[‘next_tag_open’] = ‘&lt;div>’;</h3>

        გამხსნელი ტეგი "შემდეგი" ბმულისათვის.

        <h3>$config[‘next_tag_close’] = ‘&lt;div>’;</h3>

        დამხურავი ტეგი "შემდეგი" ბმულისათვის.



        <h2>"წინა" ბმულის შექმნა</h2>

        <h3>$config[‘prev_link’] = ‘წინა’;</h3>
        ან
        <h3>$config[‘prev_link’] = ‘&lt;’;</h3>


        <h3>$config[‘prev_tag_open’] = ‘&lt;div>’;</h3>

        გამხსნელი ტეგი "წინა" ბმულისათვის.

        <h3>$config[‘prev_tag_close’] = ‘&lt;div>’;</h3>

        დამხურავი ტეგი "წინა" ბმულისათვის.



        <h2>"მიმდინარე" ბმულის შექმნა</h2>

        <h3>$config[‘cur_tag_open’] = ‘&lt;b>’;</h3>

        გამხსნელი ტეგი "მიმდინარე" ბმულისათვის.

        <h3>$config[‘cur_tag_close’] = ‘&lt;b>’;</h3>

        დამხურავი ტეგი "მიმდინარე" ბმულისათვის.

        <h3>პაგინაციის ბმულების ატრიბუტები</h3>

        დავუშვათ გვინდა, რომ პაგინაციის ბმულებს დავუმატოთ ახალი ატრიბუტები. ამისათვის პაგინაციის კონფიგურაციულ მასივს - <b>$config</b>-ს
        უნდა დავუმატოთ შემდეგი გასაღები
        <code>
          // შედეგი: class="myclass"  <br />
          $config['attributes'] = array('class' => 'myclass');
        </code>




      </dd>

      <dt>5. CI - session კლასი</dt>
      <dd class='answer'>

        <h2>სესიის ინიციალიზაცია</h2>

        სესიის ინიციალიზაცია შეიძლება მოხდეს კონტროლერის კონსტრუქტორში, ან ასესიების კლასი ვტომატურად ჩაიტვირთოს სისტემის მიერ. კონტროლერის
        კონსტრუქტორში უნდა გამოვიყენოთ შემდეგი ჩანაწერი
        <code>
          $this->load->library('session');
        </code>
        <b>იმის გამო, რომ კლასის ინიციალიზაცია ხდება CI-ს საბაზისო კონტროლერის მიხედვით, კონტროლერის კონსტრუქტორში ბიბლიოთეკის ჩატვირთვამდე
        უნდა გამოვიყენოთ parent::__construct() ჩანაწერი.</b>  ამის შემდეგ სესიების გამოყენება მოხდება ასე
        <code>
          $this->session
        </code>

        <h2>სესიაში მოთავსებული ინფორმაციის დაბრუნება</h2>

        სესიის მასივში მოთავსებული ინფორმაციის ნებისმიერი ნაწილის დაბრუნება შესაძლებელია <b>$_SESSION</b> სუპერგლობალური ცვლადის მეშვეობით
        <code>
          $_SESSION['item']
        </code>
        ან მაგიური გეტერის მეშვეობით
        <code>
          $this->session->item
        </code>
        ან <b>userdata()</b> მეთოდის მეშვეობით
        <code>
          $this->session->userdata('item');
        </code>
        სადაც "item" არის საძიებელი ინფორმაციის შესაბამისი გასაღები $_SESSION მასივში, მაგალითად გვსურს დავაბრუნოთ "name" გასარების მნიშვნელობა და
        შევინახოთ ცვლადში $name
        <code>
          <pre>
$name = $_SESSION['name'];

// ან:

$name = $this->session->name

// ან:

$name = $this->session->userdata('name');
          </pre>
        </code>
        userdata() მეთოდი აბრუნებს NULL-ს თუ შესაბამისი გასარების მნიშვნელობა არ არის განსაზღვრული.

        <h2>სესიის ინფორმაციის დამატება</h2>

        დავუშვათ რომ ჩვენს საიტზე დარეგისტრირდა ახალი მომხმარებელი. აუთჰენტიკაციის შემდეგ ჩვენ შეგვიძლია მისი სახელი და ელ_ფოსტა დავამატოთ სესიაში,
        რათა ეს მონაცემები იყოს გლობალურად ხელმისაწვდომი ჩვენთვის, მბ-სთან დაკავშირების გარეძშე. ამისათვის ეს მონაცემები უნდა გადავცეთ $_SESSION მასივს,
        ალტერნატიულ ვარიანტში შეგვიძლია გამოვიყენოთ “userdata” მეთოდი
        <code>
          $this->session->set_userdata($array);
        </code>
        სადაც  $array არის მასივი რომელიც შეიცავს სესიაში დასამატებელ ინფორმაციას
        <code>
          <pre>
$newdata = array(
        'username'  => 'johndoe',
        'email'     => 'johndoe@some-site.com',
        'logged_in' => TRUE
);

$this->session->set_userdata($newdata);
          </pre>
        </code>
        იმის გადასამოწმებლად უკვე ხომ არ არსებობს სესიაში ესა თუ ის მნიშვნელობა, უნდა გამოვიყენოთ <b>isset()</b> ფუნქცია
        <code>
          // დააბრუნებს FALSE-ს თუ სესია არ შეიცავს 'some_name' მნიშვნელობას ან ეს მნიშვნელობა უდრის NULL-ს, <br />
          // TRUE სხვა შემთხვევაში: <br />
          isset($_SESSION['some_name'])
        </code>
        ალტერნატიული ვარიანტია <b>has_userdata()</b> მეთოდის გამოყენება
        <code>
          $this->session->has_userdata('some_name');
        </code>



        <h2>სესიის ინფორმაციის წაშლა</h2>

        <code>
          <pre>
unset($_SESSION['some_name']);

// ან რამოდენიმე მნიშვნელობა ერთად :

unset(
        $_SESSION['some_name'],
        $_SESSION['another_name']
);
          </pre>
        </code>
        ალტერნატიული ვარიანტია <b>unset_userdata()</b> მეთოდის გამოყენება
        <code>
          $this->session->unset_userdata('some_name');
        </code>
        რამოდენიმე მნიშვნელობის ერთდროულად წასაშლელად, მეთოდს უნდა გადავცეთ მასივი
        <code>
          $array_items = array('username', 'email'); <br />
          $this->session->unset_userdata($array_items);
        </code>


        <h2>Flashdata</h2>

        CI-ში ჩადგმულია სესიური ინფორმაცია, ე.წ "Flashdata", ეს არის ინფორმაცია რომლის გამოყენებაც ხდება ერთჯერადად და შემდეგ ავტომატურად სუფთავდება. "Flashdata"-ს გამოყენება ხელსაყრელია სხვადასხვა სახის შეტყობინებების გამოსატანად (შეცდომა, სტატუსი, გაფრთხილება და ა.შ),
        მას შეიძლება ჰქონდეს ამდაგვარი ტექსტი "სიახლე წარმატებით დაემატა", "შეტყობინება გაგავნილია" და ა.შ. რაიმე ჩანაწერის "Flashdata"-ად
        მონიშვნა ხდება შემეგნაირად
        <code>
          $this->session->mark_as_flash('item');
        </code>
        ან რამდენიმე ჩანაწერის ერთდროულად მონიშვნა
        <code>
          $this->session->mark_as_flash(array('item', 'item2'));
        </code>
        მონიშვნის შემდეგ კი ეს ინფორმაცია უნდა გადეცეს სესიას
        <code>
          $this->session->set_flashdata('item', 'value');
        </code>
        "Flashdata"-ში მოქცეული ინფორმაციის წაკითხვა ხდება ისევე როგორც სესიაში მოქცეული სხვა ინფორმაციისა
        <code>
          $_SESSION['item']
        </code>
        თუმცა შესაძლებელია ამ ინფორმაციის ასე წაკითხვაც
        <code>
          $this->session->flashdata('item');
        </code>

        მაგალითისათვის მოვიყვანოთ ასეთი შემთხვევა: ვთქვათ დარეგისტრირდა ახალი მომხმარებელი, რეგისტრაციის შემდეგ კი ხდება მთავარ გვერდზე გადამისამართება (redirect) და გვსურს, რომ ამ გვერდზე მომხმარებელმა იხილოს შეტყობინება "თქვენ წარმატებით დარეგისტრირდით". კონტროლერის
        იმ ნაწილს, რომელიც გადამისამარტებას ახდენს ექნება შემდეგი სახე
        <code>
          <pre>
...

// შეტყობინების განსაზღვრა
$this->session->set_flashdata('user_registered','თქვენ წარმატებით დარეგისტრირდით');

redirect('index');
          </pre>
        </code>
        <b>set_flashdata</b> ფუნქციას პირველ პარამეტრად გადავეცით "flashdata" ინფორმაციის დასახელება, მეორე პარამეტრად კი შესაბამისი ტექსტი.
        ახლა გამოვიყენოთ ეს შეტყობინება index გვერდზე 
        <code>
          <pre>
&lt;?php if($this->session->flashdata('user_registered')) : ?>
    &lt;p class="alert alert-success"><?php echo $this->session->flashdata('user_registered'); ?>&lt;/p>
&lt;?php endif; ?>
          </pre>
        </code>


        <h2>Tempdata</h2>

        CI-ში ჩადგმულია სესიური ინფორმაცია, ე.წ "Tempdata", ეს არის ინფორმაცია, რომელსაც განსაზღვრული აქვს მოქმედები ვადა, ვადის გასვლის შემდეგ ხდება ამ ინფორმაციის წაშლა. ინფორმქაციის “tempdata”-ად მონიშვნა ხდება შემდეგნაირად
        <code>
          // 'item' წაიშლება 300 წამის შემდეგ <br />
          $this->session->mark_as_temp('item', 300);
        </code>
        მოვნიშნოთ რამოდენიმე ინფორმაცია ერთდროულად
        <code>
          <pre>
//  'item' და 'item2' წაიშლება 300 წამში
$this->session->mark_as_temp(array('item', 'item2'), 300);

// 'item' წაიშლება  300 წამში,  'item2'
// კი წაიშლება  240 წამში
$this->session->mark_as_temp(array(
        'item'  => 300,
        'item2' => 240
));
          </pre>
        </code>
        მონიშვნის შემდეგ შესაძლებელია დავამატოთ ინფორმაცია სესიაში
        <code>
          $this->session->set_tempdata('item', 'value', 300);
        </code>
        ამ ინფორმაციის წაკითხვა კი ხდება შემდეგნაირად
        <code>
          $this->session->tempdata('item');
        </code>


        <h2>სესიის დახურვა</h2>

        სესიის დახურვა შესაძლებელია ჩვეულებრივი PHP ფუნქციით - <b>session_destroy()</b>, ან CI ფუნქციით <b>sess_destroy()</b>
        <code>
          session_destroy(); <br /><br />

          // ან <br /><br />

          $this->session->sess_destroy();
        </code>



      </dd>


   </dl>

  </div>


  <BR><BR>

  <div class="content">
      <h2 style="margin-left: 25px;">CI - მონაცემთა ბაზასთან მუშაობა</h2>
  </div>

  <BR><BR>

  <div class="content">
      <dl class="faqs">


      <dt>1. CI - მბ-ს სწრაფი გაშვება, კოდის ნიმუში </dt>
      <dd class='answer'>

        <h2>მონაცემთა ბაზის კლასის ინიციალიზაცია</h2>

        <code>
          $this->load->database();
        </code>

        <h2>სტანდარტული მოთხოვნა რამოდენიმე შედეგით (ობიექტის მაგალითი)</h2>

        <code>
          <pre>
$query = $this->db->query('SELECT name, title, email FROM my_table');

foreach ($query->result() as $row)
{
        echo $row->title;
        echo $row->name;
        echo $row->email;
}

echo 'Total Results: ' . $query->num_rows();
          </pre>
        </code>
        <b>result()</b> ფუნქცია დააბრუნებს <b>ობიექტების</b> მასივს. მაგ: <b>$row->title</b>.



        <h2>სტანდარტული მოთხოვნა რამოდენიმე შედეგით (მასივის მაგალითი)</h2>

        <code>
          <pre>
$query = $this->db->query('SELECT name, title, email FROM my_table');

foreach ($query->result_array() as $row)
{
        echo $row['title'];
        echo $row['name'];
        echo $row['email'];
}
          </pre>
        </code>
        <b>result()</b> ფუნქცია დააბრუნებს <b>მასივს</b> სტანდარტული ინდექსებით. მაგ: <b>$row[‘title’]</b>.



        <h2>სტანდარტული მოთხოვნა ერთი შედეგით (ობიექტის მაგალითი)</h2>

        <code>
          $query = $this->db->query('SELECT name FROM my_table LIMIT 1'); <br />
          $row = $query->row(); <br />
          echo $row->name;  <br />
        </code>
        <b>row()</b> ფუნქცია დააბრუნებს <b>ობიექტს</b>. მაგ: <b>$row->name</b>.


        <h2>სტანდარტული მოთხოვნა ერთი შედეგით (მასივის მაგალითი)</h2>

        <code>
          $query = $this->db->query('SELECT name FROM my_table LIMIT 1'); <br />
          $row = $query->row_array(); <br />
          echo $row['name'];
        </code>
        <b>row_array() </b> ფუნქცია დააბრუნებს <b>მასივს</b>. მაგ: <b>$row[‘name’]</b>.


        <h2>სტანდარტული INSERT ბრძანება</h2>

        <code>
          $sql = "INSERT INTO mytable (title) VALUES (".$this->db->escape($title).")"; <br />
          $this->db->query($sql); <br />
          echo $this->db->affected_rows();
        </code>


        <h2>Query Builder ბრძანება</h2>

        Query Builder ანუ მოთხოვნათა ამგები, შემქმნელი საშუალებას გვაძლევს გავამარტივოთ მონაცემთა ამოღების სინტაქსი, მასზე ვისაუბრებთ მოგვიანებით.
        <code>
          <pre>
$query = $this->db->get('table_name');

foreach ($query->result() as $row)
{
        echo $row->title;
}
          </pre>
        </code>
        <b>get()</b> ფუნქცია ამოიღებს ყველა ჩანაწერს მითითებული ცხრილიდან.


        <h2>Query Builder Insert</h2>

        <code style="overflow-x: scroll;">
          <pre>
$data = array(
        'title' => $title,
        'name' => $name,
        'date' => $date
);

$this->db->insert('mytable', $data);  // შედეგი : INSERT INTO mytable (title, name, date) VALUES ('{$title}', '{$name}', '{$date}')
          </pre>
        </code>

      </dd>

      <dt>2. CI - მბ კონფიგურაცია</dt>
      <dd class='answer'>

        მონაცემთა ბაზის კონფიგურაციული პარამეტრების განსაზღვრა ხდება <b>application/config/database.php </b> ფაილში, ხშირად საჭიროა
        მბ-გავმართოთ  განსხვავებული  გარემოებისათვის (შექმნის გარემო ანუ როცა პროექტი კეთდება და მეორე - როცა პროქტი უკვე გაშვებულია წარმოებაში),
        CI-ს მრავალგანზომილებიანი  მასივის მეშვეობით შესაძლებელია მბ-ს პარამეტრების განსაზღვრა სხვადასხვა გარემოებისათვის, კონფიგურაციული პარამეტრები
        მასივში შემდეგნაირადაა  მოთავსებული
        <code>
          <pre>
$db['default'] = array(
    'dsn'   => '',
    'hostname' => 'localhost',
    'username' => 'root',
    'password' => '',
    'database' => 'database_name',
    'dbdriver' => 'mysqli',
    'dbprefix' => '',
    'pconnect' => TRUE,
    'db_debug' => TRUE,
    'cache_on' => FALSE,
    'cachedir' => '',
    'char_set' => 'utf8',
    'dbcollat' => 'utf8_general_ci',
    'swap_pre' => '',
    'encrypt' => FALSE,
    'compress' => FALSE,
    'stricton' => FALSE,
    'failover' => array()
);
          </pre>
        </code>
        მასივის ელემენტები შეგვიძლია დავტოვოთ უცვლელად გარდა შემდეგი ელემენტებისა : <b>hostname, username, password, database და dbdriver.</b>
        <ul class="list">
          <li><b>hostname</b> &minus; აქ უნდა განისაზღვროს მბ-ს მდებარეობა მაგ:  localhost ან IP მისამართი.</li>
          <li><b>username</b> &minus; აქ უნდა განისაზღვროს მბ-ს მომხმარებლის სახელი.</li>
          <li><b>password</b> &minus; აქ უნდა განისაზღვროს მბ-ს მომხმარებლის პაროლი.</li>
          <li><b>database</b> &minus; აქ უნდა განისაზღვროს მბ-ს სახელი.</li>
          <li><b>dbdriver</b> &minus; აქ უნდა განისაზღვროს მბ-ს ტიპი, მაგ: MySQL, MySQLi, Postgre SQL, ODBC,  MS SQL.</li>
        </ul>

        მბ-ს ზოგიერთი დრაივერისათვის (მაგ: PDO), შესაძლებელია საჭირო გახდეს DSN-ის (database source name) მთლიანი სტრიქონის ჩაწერა.
        <code>
          // PDO  <br />
          $db['default']['dsn'] = 'pgsql:host=localhost;port=5432;dbname=database_name';
        </code>


        თუ გვსურს სხვადასხვა სამუშაო გარემოსათვის სხვადასხვა ბაზებთან დაკავშირება მაშინ  ზემოთ მოყვანილი მასივის <b>$db['default']</b> გასაღები უნდა
        შევცვალოთ, და განვსაზღვროთ მბ-ს სხვა კონფიგურაციული პარამეტრები, ამ გასაღებს  მივანიჭოთ მაგალითად "test" მნიშვნელობა და აღვწეროთ პარამეტრები
        ისე რომ არ შევეხოთ ძირითად კონფიგურაციას.
        <code>
          <pre>
$db['test'] = array(
      'dsn'   => '',
      'hostname' => 'localhost',
      'username' => 'root',
      'password' => '',
      'database' => 'database_name',
      'dbdriver' => 'mysqli',
      'dbprefix' => '',
      'pconnect' => TRUE,
      'db_debug' => TRUE,
      'cache_on' => FALSE,
      'cachedir' => '',
      'char_set' => 'utf8',
      'dbcollat' => 'utf8_general_ci',
      'swap_pre' => '',
      'encrypt' => FALSE,
      'compress' => FALSE,
      'stricton' => FALSE,
      'failover' => array()
);
          </pre>
        </code>
        შემდეგ კი სისტემას მივაწოდოთ ინფორმაცია, თუ რომელი ბაზის ჩატვირთვა გვსურს
        <code>
          $active_group = 'test';
        </code>

        <h2>მოთხოვნათა შემქმნელი (Query Builder)</h2>

        მოთხოვნათა შემქმნელის კლასის გამოსართავად ან ჩასართთავად <b>$query_builder</b> ცვლადს უნდა მივანიჭოთ ლოგიკური მნიშვნელობები TRUE/FALSE ,
        ნაგულისხმეობის პრინციპით ცვლადის მნიშვნელობა არის TRUE  ანუ ეს კლასი ჩართულია ავტომატურად.
        <code>
          $query_builder = TRUE;
        </code>


      </dd>

      <dt>3. CI - მბ-სთან დაკავშირება</dt>
      <dd class='answer'>

        მბ-სთან დაკავშირება შესაძლებელია ორნაირად
        <ul>
          <li>
            <b>ავტომატური დაკავშირება</b> - ეს შესაძლებელია <b>application/config/autoload.php</b> ფაილის დახმარებით, ბაზასთან ავტომატური დაკავშირება  მოხდება
            ვებ-გვერდის ყველა ქვე-გვერდზე. ამისათვის უბრალოდ database ბიბლიოთეკა უნდა დავამატოთ <b>$autoload['libraries']</b> მასივში
          </li>
        </ul>
        <code>
          $autoload['libraries'] = array(‘database’);
        </code>

        <ul>
          <li>
            <b>სამომხმარებლო დაკავშირება</b> - თუ ბაზასთან დაკავშირება საჭიროა მხოლოდ რამოდენიმე გვერდზე, მაშინ ავტომატური დაკავშირება არ გამოგვადგება,
            ამ შემთხვევაში ბაზასთან დასაკავშირებლად რომელიმე კლასში უნდა დავამატოთ შემდეგი ხაზი.
          </li>
        </ul>
        <code>
          $this->load->database();
        </code>
        ამ ჩანაწერში არანაირი არგუმენტის მითითება არ ხდება რადგან ყველაფერი მითითებულია <b>application/config/database.php</b> ფაილში.

        <p>
          ადრე ვთქვით რომ შესაძლებელია მბ კონფიგურაციის სხვადასხვა ჯგუფების შექმნა სხვადასხვა სამუშაო გარემოებისათვის, ამ ჯგუფების ამორჩევა ხდება
          შემდეგნაირად.
        </p>
        <code>
          $this->load->database('group_name');
        </code>
        სადაც "group_name" არის ჯგუფის სახელი (მაგალითად ჩვენ რომ გავაკეთეთ "test" ჯგუფი).


        <h2>მბ-სთან კავშირის დახურვა</h2>

        <code>
          $this->db->close();
        </code>

      </dd>

      <dt>4. CI - მოთხოვნათა გაშვება</dt>
      <dd class='answer'>

        <h2>საბაზისო მოთხოვნები</h2>

        <h3>რეგულარული მოთხოვნები</h3>

        მოთხოვნის გასაგზავნად გამოიყენება <b>query</b> ფუნქცია.
        <code>
          $this->db->query('YOUR QUERY HERE');
        </code>
        <b>query()</b> ფუნქცია აბრუნებს მოთხოვნის პასუხის <b>ობიექტს</b> იმ შემთხვევაში თუ მოთხოვნა <b>წაკითხვის</b> ტიპისაა, ამ შედეგის
        გამოტანაზე  ქვემოთ ვისაუბრებთ, როცა <b>ჩაწერის</b> ტიპის მოთხოვნა სრულდება, ფუნქცია აბრუნებს <b>TRUE ან FALSE</b> მნიშვნელობებს
        წარმატებიდან გამომდინარე,  როდესაც შედეგის მიღება, დაჭერა გვსურს ის უნდა მოვათავსოთ ჩვენს საკუთარ ცვლადში
        <code>
          $query = $this->db->query('YOUR QUERY HERE');
        </code>

        <h3>გამარტივებული მოთხოვნები</h3>

        <b>simple_query</b> მეთოდი არის  $this->db->query() მეთოდის გამარტივებული ვერსია, ამ მეთოდის <b>ერთადერთი</b> დანიშნულებაა
        <b>მოთხოვნის  გაგზავნა</b>, <b>წაკითხვის</b> ტიპის მოთხოვნებთან მუშაობისას (INSERT, DELETE ან UPDATE), მეთოდი აბრუნებს  TRUE/FALSE
        მნიშვნელობებს, წარმატებიდან  გამომდინარე
        <code>
          <pre>
if ($this->db->simple_query('YOUR QUERY')){
  echo "Success!";
}
else{
  echo "Query failed!";
}
          </pre>
        </code>

        <h2>უსაფრთხოება</h2>

        უსაფრთხოების ძალიან კარგი პრაქტიკაა თუ დავამუშავებთ მონაცემებს ბაზაში გაგზავნამდე, CI-ს აქვს სამი მეთოდი ამისათვის
        <ol>
          <li>
            <b>$this->db->escape()</b> - ეს ფუნქცია ადგენს მონაცემთა ტიპს და მუშაობს მხოლოდ სტრიქონულ მონაცემებთან. ფუნქცია ავტომატურად
             ამატებს ერთმაგ ბრჭყალებს მონაცემის ირგვლივ ასე რომ ჩვენ აღარ გვჭირდება შემდეგი ჩანაწერის გაკეთება
             <code>
               $sql = "INSERT INTO table (title) VALUES(".$this->db->escape($title).")";
             </code>
          </li>
          <li>
            <b>$this->db->escape_str()</b> - ეს ფუნქცია მუშაობს ნებისმიერი ტიპის ინფორმაციასთან მაგრამ გამოიყენება იშვიათად
             <code>
               $sql = "INSERT INTO table (title) VALUES('".$this->db->escape_str($title)."')";
             </code>
          </li>
          <li>
            <b>$this->db->escape_like_str()</b> - ეს ფუნქცია გამოიყენება როდესაც სტრიქონული ინფორმაცია ჩართულია LIKE ტიპის მოთხოვნებში.
             <code>
               $search = '20% raise'; <br />
               $sql = "SELECT id FROM table WHERE column LIKE '%" . <br />
               $this->db->escape_like_str($search)."%' ESCAPE '!'"; <br />
             </code>
          </li>
        </ol>


        <h3>მოთხოვნათა მაკავშირებლები</h3>

        მოთხოვნათა მაკავშირებლები საშუალებას გვაძლევენ გავამარტივოთ მოთხოვნის სინტაქსი
        <code>
          $sql = "SELECT * FROM some_table WHERE id = ? AND status = ? AND author = ?";<br />
          $this->db->query($sql, array(3, 'live', 'Rick'));
        </code>
        ეს კითხვის ნიშნები ავტომატურად შეიცვლება query ფუნქციის მეორე პარამეტრად მითითებული მასივის ელემენტებით. მაკავშირებლები გამოიყენება
        <b>IN</b> ოპერატორთან მუშაობისასაც
        <code>
          $sql = "SELECT * FROM some_table WHERE id IN ? AND status = ? AND author = ?";<br />
          $this->db->query($sql, array(array(3, 6), 'live', 'Rick'));
        </code>
        ეს მოთხოვნა დაგენერირდება ასე
        <code>
          SELECT * FROM some_table WHERE id IN (3,6) AND status = 'live' AND author = 'Rick'
        </code>


        <h3>შეცდომათა დამუშავება</h3>

        <h4>$this->db->error();</h4>

        თუ გვჭირდება ბოლოს დაშვებული შეცდომის გამოტანა უნდა გამოვიყენოთ <b>error()</b> მეთოდი, რომელიც დააბრუნებს მასივს შეცდომის კოდითა
        და შეცდომის  შეტყობინებით
        <code>
          <pre>
if ( ! $this->db->simple_query('SELECT `example_field` FROM `example_table`')){
  $error = $this->db->error(); // აქვს გასაღებები 'code' და 'message'
}
          </pre>
        </code>


      </dd>

      <dt>5. CI - მოთხოვნის შედეგთა გენერირება</dt>
      <dd class='answer'>

        <h2>შედეგები მასივში</h2>

        <h3>result()</h3>

        ეს მეთოდი შედეგს აბრუნებს როგორც ობიექტთა მასივს ან აბრუნებს ცარიელ მასივს წარუმატებლობის შემთხვევაში, როგორც წესი მისი დამუშავება ხდება
        <b>foreach</b> ციკლში
        <code>
          <pre>
$query = $this->db->query("YOUR QUERY");

foreach ($query->result() as $row){
  echo $row->title;
  echo $row->name;
  echo $row->body;
}
          </pre>
        </code>

        <h3>result_array()</h3>

        ეს მეთოდი შედეგს ინახავს ჩვეულებრივ მასივში, თუ შედეგი არ ბრუნდება მასივი ცარიელია, როგორც წესი მისი დამუშავება ხდება  <b>foreach</b> ციკლში
        <code>
          <pre>
$query = $this->db->query("YOUR QUERY");

foreach ($query->result_array() as $row){
  echo $row['title'];
  echo $row['name'];
  echo $row['body'];
}
          </pre>
        </code>

        <h2>შედეგთა სტრიქონები</h2>

        <h3>row()</h3>

        ეს მეთოდი აბრუნებს შედეგთა მხოლოდ ერთ ჩანაწერს, სტრიქონს, თუ შედეგად რამოდენიმე ჩანაწერი ამოირჩევა ცხრილიდან მეთოდი დააბრუნებს პირველ
        მათგანს. შედეგი ბრუნდება <b>ობიექტის</b> სახით
        <code>
          <pre>
      $query = $this->db->query("YOUR QUERY");

      $row = $query->row();

      if (isset($row)){
        echo $row->title;
        echo $row->name;
        echo $row->body;
      }
          </pre>
        </code>
        თუ კონკრეტული ჩანაწერის ამოღება გვსურს შედეგთა ჯგუფიდან მაშინ row() მეთოდს პარამეტრად უნდა მივუთითოთ ამ ჩანაწერის ნომერი
        <code>
        $row = $query->row(5);
        </code>

        <h3>row_array()</h3>

        ეს მეთოდი არის წინა მეთოდის იდენტური, უბრალოდ შედეგად ბრუნდება <b>მასივი</b> და არა ობიექტი
        <code>
          <pre>
      $query = $this->db->query("YOUR QUERY");

      $row = $query->row_array();

      if (isset($row)){
        echo $row['title'];
        echo $row['name'];
        echo $row['body'];
      }
          </pre>
        </code>
        თუ კონკრეტული ჩანაწერის ამოღება გვსურს შედეგთა ჯგუფიდან მაშინ row() მეთოდს პარამეტრად უნდა მივუთითოთ ამ ჩანაწერის ნომერი
        <code>
        $row = $query->row_array(5);
        </code>

        შედეგთა ჯგუფში ნავიგაციისათვის ანუ მოძრაობისათვის გამოიყენება შემდეგი ვარიანტები
        <code>
          $row = $query->first_row()<br />
          $row = $query->last_row()<br />
          $row = $query->next_row()<br />
          $row = $query->previous_row()
        </code>
        ნაგულისმეობის პრინციპით ეს მეთოდები აბრუნებენ ობიექტებს, თუ გვსურს რომ დააბრუნონ მასივები მაშინ პარამეტრად უნდა მივუთითოთ სიტყვა
        “array”
        <code>
          $row = $query->first_row('array')<br />
          $row = $query->last_row('array')<br />
          $row = $query->next_row('array')<br />
          $row = $query->previous_row('array')
        </code>


        <h2>შედეგთა დამუშავების დამხმარე მეთოდები</h2>

        <h3>num_rows()</h3>

        მეთოდი გამოიყენება დაბრუნებული ჩანაწერების რაოდენობის დასათვლელად
        <code>
          $query = $this->db->query('SELECT * FROM my_table');<br />
          echo $query->num_rows();
        </code>

        <h3>num_fields()</h3>

        მეთოდი გამოიყენება მოთხოვნის შედეგში შემავალი ველების რაოდენობის დასათვლელად
        <code>
          $query = $this->db->query('SELECT * FROM my_table');<br />
          echo $query->num_fields();
        </code>

      </dd>

      <dt>6. CI - მოთხოვნათა დამხმარე ფუნქციები</dt>
      <dd class='answer'>


        <h2>ინფორმაცია მოთხოვნის შესრულების შესახებ</h2>

        <h3>$this->db->insert_id()</h3>

        მბ-ს ცხრილში ჩანაწერების შეტანისას აბრუნებს ჩასმული ჩანაწერის ID-ს.

        <h3>$this->db->affected_rows()</h3>

        აბრუნებს იმ ჩანაწერთა რაოდენობას, რომლებიც ცვლილებას განიცდიან "ჩასაწერი" ტიპის მოთხოვნათა შესრულების დროს (insert, update, ..)

        <h3>$this->db->last_query()</h3>

        აბრუნებს ბოლოს გაშვებულ მოთხოვნას (მოთხოვნის ტექსტს და არა შედეგს)
        <code>
          $str = $this->db->last_query(); // Produces:  SELECT * FROM sometable....
        </code>


        <h2>ინფორმაცია მბ-ს შესახებ</h2>

        <h3>$this->db->count_all()</h3>

        საშუალებას გვაძლევს გავიგოთ თუ რამდენი ჩანაწერია კონკრეტულ ცხრილში, პარამეტრად უნდა გადაეცეს ცხრილის სახელი
        <code>
          echo $this->db->count_all('my_table'); // მაგ:  25
        </code>


        <h3>$this->db->platform()</h3>

        აბრუნებს მბ-ს პლატფორმას (MySQL, MS SQL, Postgres, ...)
        <code>
          echo $this->db->platform();
        </code>

        <h3>$this->db->version()</h3>

        აბრუნებს მბ-ს ვერსიას
        <code>
          echo $this->db->version();
        </code>


        <h2>მოთხოვნათა გამარტივება</h2>

        <h3>$this->db->insert_string()</h3>

        ფუნქცია ამარტივებს მბ-ში ინფორმაციის შეტანის პროცესს
        <code>
          $data = array('name' => $name, 'email' => $email, 'url' => $url);<br />
          $str = $this->db->insert_string('table_name', $data);
        </code>
        პირველი პარამეტრი არის ცხრილის სახელი მეორე კი ასოციაციური მასივი სადაც შეტანილია ველთა დასახელებები გასაღებების სახით და შესატანი მონაცემები
        ამ გასაღებთა მნიშვნელობების სახით.
        ზემოთ მოყვანილი კოდი იმუშავებს ასე
        <code>
          INSERT INTO table_name (name, email, url) VALUES ('Rick', 'rick@example.com', 'example.com')
        </code>


        <h3>$this->db->update_string()</h3>

        ფუნქცია ამარტივებს მბ-ში ინფორმაციის განახლების პროცესს
        <code>
          $data = array('name' => $name, 'email' => $email, 'url' => $url);<br />
          $where = "author_id = 1 AND status = 'active'";<br />
          $str = $this->db->update_string('table_name', $data, $where);
        </code>
        პირველი პარამეტრი არის ცხრილის სახელი მეორე კი ასოციაციური მასივი სადაც შეტანილია ველთა დასახელებები გასაღებების სახით და შესატანი მონაცემები
        ამ გასაღებთა მნიშვნელობების სახით. მოყვანილი კოდი იმუშავებს ასე
        <code>
          INSERT INTO table_name (name, email, url) VALUES ('Rick', 'rick@example.com', 'example.com')
        </code>
        პირველი პარამეტრი არის ცხრილის სახელი მეორე კი ასოციაციური მასივი სადაც შეტანილია ველთა დასახელებები გასაღებების სახით და შესატანი გასანახლებელი
        ამ გასაღებთა მნიშვნელობების სახით, მესამე პარამეტრი კი განსაზღვრავს “where” წინადადებას მოყვანილი კოდი იმუშავებს ასე
        <code>
          UPDATE table_name SET name = 'Rick', email = 'rick@example.com', url = 'example.com' WHERE author_id = 1 AND status = 'active'
        </code>

      </dd>

      <dt>7. CI - მოთხოვნათა შექმნის კლასი (Query Builder)</dt>
      <dd class='answer'>

        CI-ში ჩადგმულია Query Builder (პირდაპირი მნიშვნელობით მოთხოვნათა ამშენებელი, შემქმნელი,) კლასი. ეს არის ერთგვარი შაბლონი, რომელიც საშუალებას
        გვაძლევს  ამოვიღოთ, განვაახლოთ ან შევიტანოთ ინფორმაცია მბ-ში კოდის მინიმალური რაოდენობის საშუალებით. ხშირ შემთხვევებში საჭიროა ორიოდ
        ხაზი კოდის დაწერა მბ-სთან დაკავშირებული რაიმე ქმედების შესასრულებლად.

        <h2>მონაცემთა ამოღება ბაზიდან</h2>

        მოვიყვანოთ ფუნქციები, რომლებიც შექმნილია <b>SQL SELECT</b> განაცხადების შესრულებისათვის

        <h3>$this->db->get()</h3>

        უშვებს ამორჩევის მოთხოვნას და აბრუნებს შედეგს, მაგალითად ამოვიღოთ ყველა ჩანაწერი ცხრილიდან
        <code>
          $query = $this->db->get('mytable');  // იგივეა რაც: SELECT * FROM mytable
        </code>
        შეგვიძლია მივუთითოთ მეორე და მესამე პარამეტრები <b>limit და offset</b>  წინადადებებისათვის
        <code>
          $query = $this->db->get('mytable', 10, 20);<br /><br />

          // შესრულდება: SELECT * FROM mytable LIMIT 20, 10<br />
        </code>
        შევნიშნოთ რომ ფუნქცია მოთავსებულია <b>$query</b> ცვლადში, რომელიც გამოიყენება შედეგის სანახავად
        <code>
          <pre>
$query = $this->db->get('mytable');

foreach ($query->result() as $row){
  echo $row->title;
}
          </pre>
        </code>

        <h3>$this->db->get_compiled_select()</h3>

        აბრუნებს SQL მოთხოვნას სტრიქონის სახით
        <code>
          $sql = $this->db->get_compiled_select('mytable');<br />
          echo $sql;  // დაბეჭდავს: SELECT * FROM mytable
        </code>


        <h3>$this->db->get_where()</h3>

        მეთოდი გამოიყენება კონკრეტული ჩანაწერის ამოსარჩევად
        <code>
          $query = $this->db->get_where('mytable', array('id' => $id), $limit, $offset);
        </code>

        <h3>$this->db->select()</h3>

        <code>
          $this->db->select('title, content, date');<br />
          $query = $this->db->get('mytable');<br /><br />

          // შესრულდება: SELECT title, content, date FROM mytable
        </code>

        <h3>$this->db->select_max()</h3>

        <code>
          $this->db->select_max('age');<br />
          $query = $this->db->get('members');  // შესრულდება: SELECT MAX(age) as age FROM members<br /><br />

          $this->db->select_max('age', 'member_age');<br />
          $query = $this->db->get('members'); // შესრულდება: SELECT MAX(age) as member_age FROM members
        </code>
        მისი ანალოგიური მეთოდია  <b>$this->db->select_min()</b>


        <h3>$this->db->select_avg()</h3>

        <code>
          $this->db->select_avg('age');<br />
          $query = $this->db->get('members'); // შესრულდება: SELECT AVG(age) as age FROM members
        </code>

        <h3>$this->db->select_sum()</h3>

        <code>
          $this->db->select_sum('age');<br />
          $query = $this->db->get('members'); // შესრულდება: SELECT SUM(age) as age FROM members
        </code>


        <h3>$this->db->join()</h3>

        <code>
          $this->db->select('*');<br />
          $this->db->from('blogs');<br />
          $this->db->join('comments', 'comments.id = blogs.id');<br />
          $query = $this->db->get();<br /><br />

          // შესრულდება:<br />
          // SELECT * FROM blogs JOIN comments ON comments.id = blogs.id
        </code>


        <h2>კონკრეტული ჩანაწერის ამოღება</h2>

        <h3>$this->db->where()</h3>

        ფუნქცია საშუალებას გვაძლევს განვსაზღვროთ <b>WHERE</b> წინადადებები შემდეგი ოთხი ვარიანტიდან ერთ-ერთის მეშვეობით

        <ol>
          <li>
            <h3>მარტივი გასაღები/მნიშვნელობა მეთოდი</h3>
            <code>
              $this->db->where('name', $name); // Produces: WHERE name = 'Joe'
            </code>
            თუ გამოვიყენებთ ამ მეთოდის რამოდენიმე ჩანაწერს, მათში შეტანილი პარამეტრები გაერთიანდება <b>AND</b> ოპერატორის მიერ
            <code>
              $this->db->where('name', $name);<br />
              $this->db->where('title', $title);<br />
              $this->db->where('status', $status);<br />
              // WHERE name = 'Joe' AND title = 'boss' AND status = 'active'
            </code>
          </li>
          <li>
            <h3>შერჩევითი გასაღები/მნიშვნელობა მეთოდი</h3>
            <code>
              $this->db->where('name !=', $name);<br />
              $this->db->where('id <', $id); // Produces: WHERE name != 'Joe' AND id < 45
            </code>
          </li>
          <li>
            <h3>ასოციაციური მასივის მეთოდი</h3>
            <code>
              $array = array('name' => $name, 'title' => $title, 'status' => $status);<br />
              $this->db->where($array);<br />
              // Produces: WHERE name = 'Joe' AND title = 'boss' AND status = 'active'
            </code>
          </li>
          <li>
            <h3>შერჩევითი სტრიქონი</h3>
            <code>
              $where = "name='Joe' AND status='boss' OR status='active'";<br />
              $this->db->where($where);
            </code>
          </li>
        </ol>

        <h3>$this->db->or_where()</h3>

        <code>
          $this->db->where('name !=', $name);<br />
          $this->db->or_where('id >', $id);  // Produces: WHERE name != 'Joe' OR id > 50
        </code>

        <h3>$this->db->where_in()</h3>

        <code>
          $names = array('Frank', 'Todd', 'James');<br />
          $this->db->where_in('username', $names);<br />
          // Produces: WHERE username IN ('Frank', 'Todd', 'James')
        </code>


        <h3>$this->db->or_where_in()</h3>

        <code>
          $names = array('Frank', 'Todd', 'James');<br />
          $this->db->or_where_in('username', $names);<br />
          // Produces: OR username IN ('Frank', 'Todd', 'James')
        </code>


        <h3>$this->db->where_not_in()</h3>

        <code>
          $names = array('Frank', 'Todd', 'James');<br />
          $this->db->where_not_in('username', $names);<br />
          // Produces: WHERE username NOT IN ('Frank', 'Todd', 'James')
        </code>



        <h2>მსგავსი ჩანაწერის ამოღება</h2>


        <h3>$this->db->like()</h3>

        <code>
          $this->db->like('title', 'match');<br />
          // Produces: WHERE `title` LIKE '%match%' ESCAPE '!'
        </code>


        <h3>$this->db->or_like()</h3>

        <code>
          $this->db->like('title', 'match'); $this->db->or_like('body', $match);<br />
          // WHERE `title` LIKE '%match%' ESCAPE '!' OR  `body` LIKE '%match%' ESCAPE '!'
        </code>


        <h3>$this->db->not_like()</h3>

        <code>
          $this->db->not_like('title', 'match');  // WHERE `title` NOT LIKE '%match% ESCAPE '!'
        </code>


        <h3>$this->db->group_by()</h3>

        <code>
          $this->db->group_by("title"); // Produces: GROUP BY title
        </code>

        <h3>$this->db->distinct()</h3>

        <code>
          $this->db->distinct();<br />
          $this->db->get('table'); // Produces: SELECT DISTINCT * FROM table
        </code>



        <h2>შედეგთა დალაგება</h2>

        <h3>$this->db->order_by()</h3>

        <code>
          $this->db->order_by('title', 'DESC');  // Produces: ORDER BY `title` DESC
        </code>


        <h2>შედეგთა ლიმიტი და დათვლა</h2>

        <h3>$this->db->limit()</h3>

        <code>
          this->db->limit(10);  // Produces: LIMIT 10
        </code>



        <h2>მონაცემთა შეტანა ცხრილში</h2>

        <h3>$this->db->insert()</h3>

        ფუნქციას ცხცრილში შესატანი მნიშვნელობები შეიძლება გადაეცეს  <b>მასივის</b> ან  <b>ობიექტის</b> სახით.

        <code>
          <pre>
$data = array(
  'title' => 'My title',
  'name' => 'My Name',
  'date' => 'My date'
);

$this->db->insert('mytable', $data);
// Produces: INSERT INTO mytable (title, name, date) VALUES ('My title', 'My name', 'My date')
           </pre>
        </code>
        პირველი პარამეტრი არის ცხრილის სახელი, მეორე კი- მასივი


        <code>
         <pre>
/*
class Myclass {
   public $title = 'My Title';
   public $content = 'My Content';
   public $date = 'My Date';
}
*/

$object = new Myclass;
$this->db->insert('mytable', $object);
// Produces: INSERT INTO mytable (title, content, date) VALUES ('My Title', 'My Content', 'My Date')
         </pre>
        </code>


        <h2>მონაცემთა განახლება ცხრილში</h2>

        <h3>$this->db->update()</h3>

        ფუნქციას ცხცრილში შესატანი მნიშვნელობები შეიძლება გადაეცეს  <b>მასივის</b> ან  <b>ობიექტის</b> სახით.

        <code>
          <pre>
$data = array(
  'title' => $title,
  'name' => $name,
  'date' => $date
);

$this->db->where('id', $id);
$this->db->update('mytable', $data);
// Produces:
//
//      UPDATE mytable
//      SET title = '{$title}', name = '{$name}', date = '{$date}'
//      WHERE id = $id
          </pre>
       </code>

       <code>
         <pre>
/*
class Myclass {
 public $title = 'My Title';
 public $content = 'My Content';
 public $date = 'My Date';
}
*/

$object = new Myclass;
$this->db->where('id', $id);
$this->db->update('mytable', $object);
// Produces:
//
// UPDATE `mytable`
// SET `title` = '{$title}', `name` = '{$name}', `date` = '{$date}'
// WHERE id = `$id`
         </pre>
      </code>


       <h2>ჩანაწერის წაშლა ცხრილში</h2>

       <h3>$this->db->delete()</h3>

       <code>
         $this->db->delete('mytable', array('id' => $id));  // Produces: // DELETE FROM mytable  // WHERE id = $id
       </code>

      </dd>

      <dt>8. CI - მეტაინფორმაცია მბ-ს შესახებ</dt>
      <dd class='answer'>

        <h2>მეტაინფორმაცია ცხრილების შესახებ</h2>

        <h3>მბ-ში არსებული ცხრილების სია</h3>

        მბ-ში არსებული ცხრილების სანახავად გამოიყენება <b>$this->db->list_tables();</b> ფუნქცია
        <code>
          <pre>
$tables = $this->db->list_tables();

foreach ($tables as $table)
{
        echo $table;
}
          </pre>
        </code>

        <h3>არსებობს თუ არა ცხრილი მბ-ში</h3>

        იმის დასადგენად არსებობს თუ არა ცხრილი მბ-ში გამოიყენება <b>$this->db->table_exists();</b> ფუნქცია. აბრუნებს TRUE/FALSE მნიშვნელობებს.
        <code>
          <pre>
if ($this->db->table_exists('table_name'))
{
        // კოდი ...
}
          </pre>
        </code>


          <h2>მეტაინფორმაცია ცხრილის ველების შესახებ</h2>

          <h3>ცხრილის ველების სია</h3>

          ცხრილის ველების სანახავად გამოიყენება <b>list_fields()</b> ფუნქცია რომელიც აბრუნებს მასივს
          <code>
            <pre>
$fields = $this->db->list_fields('table_name');

foreach ($fields as $field)
{
        echo $field;
}
            </pre>
          </code>

          <h3>არსებობს თუ არა ცხრილი ესა თუ ის ველი</h3>

          ამის დასადგენად გამოიყენება <b>field_exists()</b> ფუნქცია, რომელიც აბრუნებს TRUE/FALSE მნიშვნელობებს.
          <code>
            <pre>
if ($this->db->field_exists('field_name', 'table_name'))
{
        // კოდი ...
}
            </pre>
          </code>


      </dd>

   </dl>

  </div>



  <BR><BR>

  <div class="content">
      <h2 style="margin-left: 25px;">CI - მარტივი შინაარსის ბლოგი</h2>
  </div>

  <BR><BR>

  <div class="content">
      <dl class="faqs">


      <dt>1. CI - მარტივი შინაარსის ბლოგი</dt>
      <dd class='answer'>

         ამ თავში შევქმნათ დინამიური შიგთავსის მქონე მინი ბლოგი მონაცემთა ბაზების გამოყენებით. 

         <h2>მოდელი</h2>

         როგორც ადრე ვთქვით, მონაცემთა ბაზასთან დაკავშირებული ბრძანებები უნდა აღიწეროს მოდელში. მოდელში აღწერილმა კოდმა უნდა
         უზრუნველჰყოს მბ-ში ინფორმაციის შეტანა, განახლება წაშლა, წაკითხვა. <b>application/models/</b> საქაღალდეში შევქმნათ
         ფაილი <b>News_model.php</b> შემდეგი კოდით
         <code>
           <pre>
&lt;?php
class News_model extends CI_Model {

        public function __construct()
        {
                $this->load->database();
        }
}
           </pre>
         </code>
         ამ მომენტისათვის უკვე განსაზღვრული უნდა გვქონდეს მონაცემთა ბაზის კონფიგურაციული პარამეტრები ("CI - მონაცემთა ბაზასთან მუშაობა"
         განყოფილების მე-2-ე თავი). ახლა შევქმნათ სიახლეების ცხრილი მონაცემთა ბაზაში და დავარქვათ მას <b>news</b>
         <code>
           <pre>
CREATE TABLE news (
        id int(11) NOT NULL AUTO_INCREMENT,
        title varchar(128) NOT NULL,
        slug varchar(128) NOT NULL,
        text text NOT NULL,
        PRIMARY KEY (id),
        KEY slug (slug)
);
           </pre>
         </code>
         ახლა მოდელში ჩავამატოთ მეთოდი <b>get_news</b>, რომელიც ამოიღებს ჩანაწერებს <b>news</b> ცხრილიდან
         <code>
           <pre>
&lt;?php
class News_model extends CI_Model {

        public function __construct()
        {
           $this->load->database();
        }

        public function get_news($slug = FALSE)
        {
           if ($slug === FALSE)
           {
              $query = $this->db->get('news');
              return $query->result_array();
           }

           $query = $this->db->get_where('news', array('slug' => $slug));
           return $query->row_array();
        }
}
           </pre>
         </code>
         <b>get_news()</b>მეთოდის მეშვეობით შესაძლებელია ორი სახის მოთხოვნის შესრულება: შეგვიძლია ცხრილიდან ამოვიღოთ ყველა
         ჩანაწერი, ან ამოვიყოთ კონკრეტული ჩანაწერი <b>$slug</b> პარამეტრის მიხედვით. 

         <h3>$slug პარამეტრის შესახებ</h3>

         $slug პარამეტრის უკან მოიაზრება URL მისამართის კონკრეტული ნაწილი, დავუშვათ გვაქვს URL მისამართი , რომელიც იღებს ყველა ჩანაწერს
         მბ-ს ცხრილიდან
         <code>
            http://localhost/news           
         </code>
         მაგრამ თუ კონკრეტული სიახლის ამოღება გვინდა მაშინ URL მისამართი მიიღებს შემდეგ სახეს
         <code>
            http://localhost/news/georgia       
         </code>
         შევნიშნოთ, რომ მისამართი ახალი სეგმენტის დამატების შემდეგაც საკმაოდ ლოგიკური და აფვილად წაკითხვადია, როგორც ადამიანისათვის,
         ასევე საძიებელი სისტემებისათვის. მისამართში გამოყენებული სიტყვა <b>georgia</b> შესაძლებელია იყოს უნიკალური იდენტიფიკატორი
         ცხრილში არსებული კონკრეტული ჩანაწერისათვის, სიახლისათვის.  დავუშვათ გვაქვს ცხრილი შემდეგი ველებით
         <code>
            id <br />
            news_title <br />
            news_author <br />
            news_unique_identifier <br />
         </code>
         ამ ცხრილიდან კონკრეტული ჩანაწერის ამოღებისას slug პარამეტრის მნიშვნელობად უნდა გამოვიყენოთ <b>news_unique_identifier</b>
         ველი.

         <p>
           ახლა დავუბრუნდეთ ჩვენს მიერ შექმნილ მოდელს
         </p>
         <code>
           <pre>
public function get_news($slug = FALSE)
{
   if ($slug === FALSE)
   {
      $query = $this->db->get('news');
      return $query->result_array();
   }

   $query = $this->db->get_where('news', array('slug' => $slug));
   return $query->row_array();
}
           </pre>
         </code>
         ამ მეთოდში აღწერილი კოდი სისტემას ეუბნება რომ თუ $slug პარამეტრის მნიშვნელობა არის FALSE, მაშინ ცხრილიდან ამოიღოს ყველა
         ჩანაწერი. ხოლო თუ URL მისამართში გაჩნდება ახალი სეგმენტი, მისი მნიშვნელობა აღიქვას როგორც $slug პარამეტრი და ცხრილიდან ამოიღოს
         ის ჩანაწერი, რომლის უნიკალური ველის (slug) მნიშვნელობაც არის ამ პარამეტრის მიმდინარე მნიშვნელობის ტოლი (get_where('news', array('slug' => $slug));).

         <h2>სიახლეების გამოტანა</h2>

         მას შემდეგ რაც მოდელში აღიწერა ჩანაწერების ამოსაღები მოთხოვნები, ეს მოდელი უნდა დაკავშირდე შესაბამის წარმოდგენასთან, რომელშიც
         მომხმარებელი იხილავს ცხრილიდან ამოღებულ სიახლეებს. შევქმნათ ახალი კონტროლერი <b>application/controllers/News.php</b>
         შემდეგი კოდით
         <code>
           <pre>
&lt;?php
class News extends CI_Controller {

        public function __construct()
        {
                parent::__construct();
                $this->load->model('news_model');
                $this->load->helper('url_helper');
        }

        public function index()
        {
                $data['news'] = $this->news_model->get_news();
        }

        public function view($slug = NULL)
        {
                $data['news_item'] = $this->news_model->get_news($slug);
        }
}
           </pre>
         </code>
         <b>__construct()</b> მეთოდი იძახებს <b>News</b> კლასის მშობელი კლასის - <b>CI_Controller</b>-ის კონსტრუქტორს, ტვირთავს
         მოდელს და URL მისამართების დამხმარეს. შემდეგ აღწერილია ორი მეთოდი: პირველი გამოიყენება ყველა ჩანაწერის სანახავად მეორე კი ერთი
         კონკრეტულისა. მეორე მეთოდში გამოძახებულ მოდელის <b>get_news()</b> ფუნქციას პარამეტრად გადაცემული აქვს <b>$slug</b> ცვლადი,
         რომელიც კონტროლერში დაფიქსირდება იმ შემთხვევაში თუ URL მისამართში გაჩნდება ახალი სეგმენტი, და რომელსაც მოდელი იყენებს კონკრეტული
         ჩანაწერის იდენტიფიკაციისათვის.
         <p>
           მას შემდეგ რაც კონტროლერსაც მივაწოდეთ საჭირო ინფორმაცია, ისღა დაგვრჩენია საქმეში ჩავრთოთ წარმოდგენის ფაილი
         </p>
         <code>
           <pre>
public function index()
{
        $data['news'] = $this->news_model->get_news();
        $data['title'] = 'News archive';

        $this->load->view('templates/header', $data);
        $this->load->view('news/index', $data);
        $this->load->view('templates/footer');
}
           </pre>
         </code>
         ეს კოდი მოდელიდან მიღებულ ყველა ჩანაწერს მოათავსებს  <b>$data</b> მასივში, აგრეთვე განსაზღვრავს სიახლეების გვერდის სათაურს
         <code>
            $data['news'] = $this->news_model->get_news(); <br />
            $data['title'] = 'News archive';           
         </code>
         სწორედ ეს მასივი უნდა გადაეცეს შესაბამის წარმოდგენას, შევქმნათ წარმოდგენის ფაილი <b>application/views/news/index.php</b>
         შემდეგი კოდით
         <code>
           <pre>
&lt;h2>&lt;?php echo $title; ?>&lt;/h2>

&lt;?php foreach ($news as $news_item): ?>

        &lt;h3>&lt;?php echo $news_item['title']; ?>&lt;/h3>
        &lt;div class="main">
                &lt;?php echo $news_item['text']; ?>
        &lt;/div>
        &lt;p>&lt;a href="&lt;?php echo site_url('news/'.$news_item['slug']); ?>">View article&lt;/a>&lt;/p>

&lt;?php endforeach; ?>
           </pre>
         </code>
         <b>foreach</b> ციკლის დახმარებით მოხდება ცხრილში არსებული ჩანაწერების ცალ-ცალკე გამოტანა წარმოდგენაში. ერთ გვერდზე ყველა ჩანაწერი
         გამოვიტანეთ, ახლა შესაქმნელია კონკრეტული სიახლის სანახავი წარმოდგენის შექმნა, ამისათვის ჯერ კონტროლერს უნდა დავამატოთ შესაბამისი
         მეთოდი <b>view</b>
         <code>
           <pre>
public function view($slug = NULL)
{
        $data['news_item'] = $this->news_model->get_news($slug);

        if (empty($data['news_item']))
        {
                show_404();
        }

        $data['title'] = $data['news_item']['title'];

        $this->load->view('templates/header', $data);
        $this->load->view('news/view', $data);
        $this->load->view('templates/footer');
}
           </pre>
         </code>
         როგორც ვხედავთ <b>get_news()</b> მეთოდს გადაეცა პარამეტრი <b>$slug</b>, კონკრეტული ჩანაწერის იდენტიფიკატორი. ახლა შევქმნათ
         წარმოდგენის ფაილი <b>application/views/news/view.php</b> შემდეგი კოდით
         <code>
           <pre>
&lt;?php
echo '&lt;h2>'.$news_item['title'].'&lt;/h2>';
echo $news_item['text'];
           </pre>
         </code>

         <h2>მარშრუტიზაცია</h2>

         განვსაზღროთ შესაბამისი მარშრუტები <b>application/config/routes.php</b> საქაღალდეში
         <code>
            $route['news/(:any)'] = 'news/view/$1'; <br />
            $route['news'] = 'news'; <br />
            $route['(:any)'] = 'pages/view/$1'; <br />
            $route['default_controller'] = 'pages/view';
         </code>


         <h1>ჩანაწერის დამატება ცხრილში</h1>

         <h2>ფორმის შექმნა</h2>

         შევქმნათა წარმოდგენის ახალი ფაილი <b>application/views/news/create.php</b> და აღვწეროთ მასში ჩანაწერის დასამატებელი ფორმა
         <code>
           <pre>
&lt;h2>&lt;?php echo $title; ?>&lt;/h2>

&lt;?php echo validation_errors(); ?>

&lt;?php echo form_open('news/create'); ?>

    &lt;label for="title">Title&lt;/label>
    &lt;input type="input" name="title" />&lt;br />

    &lt;label for="text">Text&lt;/label>
    &lt;textarea name="text">&lt;/textarea>&lt;br />

    &lt;input type="submit" name="submit" value="Create news item" />

&lt;/form>
           </pre>
         </code>
         ახლა კონტროლერში დავამატოთ ჩანაწერის დასამატებელი მეთოდი <b>create</b>
         <code>
           <pre>
public function create()
{
    $this->load->helper('form');
    $this->load->library('form_validation');

    $data['title'] = 'Create a news item';

    $this->form_validation->set_rules('title', 'Title', 'required');
    $this->form_validation->set_rules('text', 'Text', 'required');

    if ($this->form_validation->run() === FALSE)
    {
        $this->load->view('templates/header', $data);
        $this->load->view('news/create');
        $this->load->view('templates/footer');

    }
    else
    {
        $this->news_model->set_news();
        $this->load->view('news/success');
    }
}
           </pre>
         </code>
        კოდის პირველი ხაზი ტვირთავს ფორმის დამხმარეს, მეორე კი - ვალიდაციის ბიბლიოთეკას. ამის შემდეგ ხდება ვალიდაციის წესების განსაზღვრა,
        <b>set_rules()</b> ფუნქციას გადაეცემა სამი პარამეტრი: ველის სახელი, ველის სახელი შეცდომებში გამოსატანად და თავად ვალიდაციის წესი.
        ამ შემთხვევაში სათაურის და ტექსტის ველების შეყვანა აუცილებელია. 
        <p>
          ამის შემდეგ მოწმდება წარმატებით დასრულდა თუ არა ვალიდაცია, თუ ვალიდაცია წარუმატებელია ისევ ფორმის გვერდზე ვრჩებით,  ხოლო თუ
          ვალიდაცია წარმატებით დასრულდება ხდება მოდელის გამოძახება. ამის შემდეგ კი იტვირთება წარმატების გვერდი შესაბამისი შეტყობინებით. 
          შევქმნათ ეს გვერდი <b>application/views/news/success.php</b> შემდეგი ტექსტით
        </p>
        <code>
          &lt;h2>სიახლე წარმატებით დაემატა.&lt;/h2>          
        </code>


        <h2>მოდელი</h2>

        ახლა საჭიროა შევქმნათ მოდელი, რომელიც მბ-ში შეიტანბს მონაცემებს. ადრე შექმნილ მოდელს დავამატოთ შემდეგი კოდი
        <code>
          <pre>
public function set_news()
{
    $this->load->helper('url');

    $slug = url_title($this->input->post('title'), 'dash', TRUE);

    $data = array(
        'title' => $this->input->post('title'),
        'slug' => $slug,
        'text' => $this->input->post('text')
    );

    return $this->db->insert('news', $data);
}
          </pre>
        </code>
        მოდელში გამოყენებულია <b>url_title()</b> ფუნქცია, ეს ფუნქცია განთავსებულია URL დამხმარეში ახდენს მიწოდებული სტრიქონის
        ჩასწორებას: გამოტოვებული ადგილები იცვლება ტირით, აგრეთვე ყველა სიტყვა იწერება პატარა ასოებით.
        <p>
          ახლა გავარკვიოთ თუ რა ხდება <b>$data</b> მასივში. მისი ყველა ელემენტი შეესაბამება მბ-ში გაკეთებული ცხრილის ველთა დასახელებებს,
          შემდეგ გამოყენებულია <b>input</b> ბიბლიოთეკის <b>post()</b> მეთოდი, რომელიც ახდენს ველებში შეყვანილი ინფორმაციის გასუფთავებას
          და გადამოწმებას.  <b>input</b> ბიბლიოთეკის ჩატვირთვა ხდება ავტომატურად, სისტემის მიერ. ამის შემდეგ კი ხდება $data მასივში
          მოთავსებული ინფორმაციის მბ-ში შეტანა.
        </p>

        <h2>მარშრუტიზაცია</h2>

        <code>
          $route['news/create'] = 'news/create'; <br />
          $route['news/(:any)'] = 'news/view/$1'; <br />
          $route['news'] = 'news'; <br />
          $route['(:any)'] = 'pages/view/$1'; <br />
          $route['default_controller'] = 'pages/view';
        </code>


      </dd>

   </dl>

  </div>


  <BR><BR>




<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.4/jquery.min.js"></script>
<script type="text/javascript">
    $(".faqs dd").hide();
    $(".faqs dt").click(function () {
        $(this).next(".faqs dd").slideToggle(500);
        $(this).toggleClass("expanded");
    });
    $("tr:odd").css({"background":"#f1f1f1"});
</script>

</body></html>
